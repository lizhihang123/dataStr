# 1 排序算法

## 冒泡排序

一句话解释：相邻的元素，两两比较，如果当前元素大于下一个元素，就要进行交换。如果小于，位置不变。

算法关键步骤：

1. 外层遍历次数，小于 len - 1次
2. 内层for循环，小于 len - i - 1次
3. [5, 3, 2, 1] 外层 表示 len - 1，小于4 - 1，就是走三趟；内层，表示，len - i - 1, 假如i是0，内层就是小于 len - 0 - 1 小于3



是原地排序

是稳定排序 -> 相同的元素的相对位置不会受到影响

```diff
		// 1. 交换 
        function swap(arr, i, j) {
            let temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
        // 2 排序
        function BubbleSort(nums) {
            let len = nums.length
            // 外面for循环 表示走几趟，走 len-1趟，[5, 3, 2, 1] 走三趟
            for (let i = 0; i < len - 1; i++) {
                // 里面的for循环 表示 每一趟走多少次，长度 - i - 1 而i表示当前是第几趟
                for (let j = 0; j < len - i - 1; j++) {
                    if (nums[j] > nums[j + 1]) {
                        swap(nums, j, j + 1)
                    }
                }
            }
            return nums
        }
```



## 冒泡排序的优化：

优化的思路，原本要交换8趟，但是在第4趟，两两元素没有进行交换了，就可以停止不需要进行交换了，通过一个变量，只要进行了交换，这个变量就是true，否则是false，是true 就return

- 每次重新外层for循环，isSorted都要改为true
- 如果进入内层循环，交换了变量，isSorted就要改为false
- 内层循环完成，就判断 是否是true，是true，表示没有进行交换。 => 后续的外层循环都不需要进行，已经交换好了
- console.log(BubbleSort([5, 2, 1, 6, 3, 7, 8, 9])); 这个测试用例，可以测出来，在i=1的时候，就已经交换完毕，后续不需要交换了

```diff
function swap(arr, i, j) {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}
// 2 排序
function BubbleSort(nums) {
    let len = nums.length
    // 外面for循环 表示走几趟，走 len-1趟，[5, 3, 2, 1] 走三趟
    for (let i = 0; i < len - 1; i++) {
+        let isSorted = true
        debugger
        if (i === 3 || i === 4) {
            debugger
        }
        // 里面的for循环 表示 每一趟走多少次，长度 - i - 1 而i表示当前是第几趟
        for (let j = 0; j < len - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1)
+                isSorted = false
            }
        }
+        if (isSorted) {
            break
        }
    }
    return nums
}
```



## 优化2：

优化的思路2：
进一步优化：不仅仅是从走8趟 -》 走4趟
且 如果有些元素已经是有序的了，就不需要再进行比较了

算法：
每次交换，更新“最后一次交换的位置” -> 后续交换元素时，边界就是“上一次更新的最后一次交换的位置”



```diff
function swap(arr, i, j) {
            let temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
        }
        // 2 排序
        function BubbleSort(nums) {
            let len = nums.length
            // 外面for循环 表示走几趟，走 len-1趟，[5, 3, 2, 1] 走三趟
+            let sortBorder = nums.length - 1
+            let lastExchangeIndex = 0
            for (let i = 0; i < len - 1; i++) {
                let isSorted = true
                debugger
                // 里面的for循环 表示 每一趟走多少次，长度 - i - 1 而i表示当前是第几趟
+                for (let j = 0; j < sortBorder; j++) {
                    debugger
                    if (nums[j] > nums[j + 1]) {
                        swap(nums, j, j + 1)
                        isSorted = false
                        // 更新为最后一次交换元素的位置
+                        lastExchangeIndex = j
                    }
                }
+                sortBorder = lastExchangeIndex
                if (isSorted) {
                    break
                }
            }
            return nums
        }
```







## 插入排序

初级写法





优化写法：目的是减少交换的次数

```js
        let insertSort = function insertSort (arr) {

            for (let i = 0; i < arr.length; i++) {
                let iIndex = i
                let moveIndex = i - 1
                let temp = arr[i]

                // 如果蓝色指针的值 小于 红色指针的值 直接continue
                if (arr[moveIndex] < arr[i]) {
                    continue
                }

                // !为什么 j 要大于-1
                for (let j = i; j > -1; j--) {

                    // 如果蓝色指针的值小于 temp的值 
                    // 1、为什么要把temp 和 蓝色指针的值进行比较
                    // 2、为什么要把temp赋值给他arr[j]
                    if (arr[j - 1] < temp) {
                        arr[j] = temp
                        break
                    }

                    // 如果蓝色指针指向 空
                    if (!arr[j - 1]) {
                        arr[j] = temp
                        break
                    }


                    // 如果蓝色指针的值 大于 红色指针的值
                    arr[j] = arr[j - 1]
                }
            }
            return arr
        }
        let initArr = [3, 5, 1, 9, 4, 2, 11, 8]
        console.log(insertSort(initArr));
```

测试用例： 5 7 6 4 8的排序

1. 执行如下代码

让temp等于5

```diff
                let iIndex = i
                let moveIndex = i - 1
                let temp = arr[i]
```

j第二层循环 执行这段, 还是让arr[0] = 5 break

```diff
                    // 如果蓝色指针指向 空
                    if (!arr[j - 1]) {
                        arr[j] = temp
                        break
                    }
```

2. i 为 7 ，j也为7， j - 1 为5 因为 5 < 7 所以执行

```diff
                // 如果蓝色指针的值 小于 红色指针的值 直接continue
                if (arr[moveIndex] < arr[i]) {
                    continue
                }
```

3. i 指向6，j指向7，temp赋值为6

因为 7 大于6 ,只执行这段。变为 5 7  7 4 8

```diff
                    // 如果蓝色指针的值 大于 红色指针的值
                    arr[j] = arr[j - 1]
```

j 为 7，j - 1位【简写 arr[j] 为7 arr[j - 1] 为 5】

因为在内层for循环里面，temp为6，还是上面初始赋值，5 < 6。 把7 改为6，变为 5 6 7 4 8

```diff
                    if (arr[j - 1] < temp) {
                        arr[j] = temp
                        break
                    }
```

4. temp是4，j - 1是7

和上面一样， 7 > 4 要变为 5 6 7 7 8

```diff
arr[j] = arr[j - 1]
```

j - 1 为 6 ,大于4， 改 7 为6，变为 5 6 6 7 8

然后5 依次类推

5 5 6 7 8

最后发现没有j - 1, 就赋值 j 为 temp

```diff
                    // 如果蓝色指针指向 空
                    if (!arr[j - 1]) {
                        arr[j] = temp
                        break
                    }
```





## 归并排序

```diff
        // 时间复杂度 O(nlogN)
        // 归 - 归类 [3, 5, 1, 9, 4, 2, 11, 8]
        /* 
            3 5 1 9 | 4 2 11 8
            3 5 | 1 9 | 4 2 | 11 8
        */
	
	function mergeSort(arr) {
            let len = arr.length
            _mergeArr(arr, 0, len - 1)
        }
        
        // 合并数组
        function _mergeArr (arr, left, right) {
            // left - 左指针
            // right - 右指针

            // 退出
            if (left >= right) {
                return
            }
            // 求mid值
            let mid = parseInt((left + right) / 2)

            // 递归
            _mergeArr(arr, left, mid)
            _mergeArr(arr, mid + 1, right)
        }
```



