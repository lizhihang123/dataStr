# 1 排序算法

## 冒泡排序

算法关键步骤：

1. 遍历阶段，两层遍历，外层遍历小于n次，n为数组的长度；内层遍历小于 len - i；
2. 冒泡阶段，如果arr[j] > arr[j + 1]就要交换。注意交换的代码。

为什么内层只遍历 len - i次，每一次遍历，冒泡交换，都会找到一个很大的值；第一大的值在最后，就可以直接舍去了

```diff
        // 冒泡排序
        // 外层走多少趟 < n 趟
        // 里层交换多少次 < n - i次


        function swap (arr, index1, index2) {
            let temp = arr[index1]
            arr[index1] = arr[index2]
            arr[index2] = temp
            return arr
        }

        // 1 遍历过程
        // 2 冒泡交换过程
        function BubbleSort(arr) {
            // 遍历过程
            let len = arr.length
            for (let i = 0; i < len; i++) {
                for (let j = 0; j < len - i; j++) {
                    // 边界情况
                    if (!arr[j + 1]) {
                        // ！问 break 跳出几层循环？能够跳出一层的for循环
                        break
                    }

                    // 冒泡过程
                    if (arr[j] > arr[j + 1]) {
                        swap(arr, j, j + 1)
                    }
                }
            }
            return arr
        }
```



## 插入排序

初级写法





优化写法：目的是减少交换的次数

```js
        let insertSort = function insertSort (arr) {

            for (let i = 0; i < arr.length; i++) {
                let iIndex = i
                let moveIndex = i - 1
                let temp = arr[i]

                // 如果蓝色指针的值 小于 红色指针的值 直接continue
                if (arr[moveIndex] < arr[i]) {
                    continue
                }

                // !为什么 j 要大于-1
                for (let j = i; j > -1; j--) {

                    // 如果蓝色指针的值小于 temp的值 
                    // 1、为什么要把temp 和 蓝色指针的值进行比较
                    // 2、为什么要把temp赋值给他arr[j]
                    if (arr[j - 1] < temp) {
                        arr[j] = temp
                        break
                    }

                    // 如果蓝色指针指向 空
                    if (!arr[j - 1]) {
                        arr[j] = temp
                        break
                    }


                    // 如果蓝色指针的值 大于 红色指针的值
                    arr[j] = arr[j - 1]
                }
            }
            return arr
        }
        let initArr = [3, 5, 1, 9, 4, 2, 11, 8]
        console.log(insertSort(initArr));
```

测试用例： 5 7 6 4 8的排序

1. 执行如下代码

让temp等于5

```diff
                let iIndex = i
                let moveIndex = i - 1
                let temp = arr[i]
```

j第二层循环 执行这段, 还是让arr[0] = 5 break

```diff
                    // 如果蓝色指针指向 空
                    if (!arr[j - 1]) {
                        arr[j] = temp
                        break
                    }
```

2. i 为 7 ，j也为7， j - 1 为5 因为 5 < 7 所以执行

```diff
                // 如果蓝色指针的值 小于 红色指针的值 直接continue
                if (arr[moveIndex] < arr[i]) {
                    continue
                }
```

3. i 指向6，j指向7，temp赋值为6

因为 7 大于6 ,只执行这段。变为 5 7  7 4 8

```diff
                    // 如果蓝色指针的值 大于 红色指针的值
                    arr[j] = arr[j - 1]
```

j 为 7，j - 1位【简写 arr[j] 为7 arr[j - 1] 为 5】

因为在内层for循环里面，temp为6，还是上面初始赋值，5 < 6。 把7 改为6，变为 5 6 7 4 8

```diff
                    if (arr[j - 1] < temp) {
                        arr[j] = temp
                        break
                    }
```

4. temp是4，j - 1是7

和上面一样， 7 > 4 要变为 5 6 7 7 8

```diff
arr[j] = arr[j - 1]
```

j - 1 为 6 ,大于4， 改 7 为6，变为 5 6 6 7 8

然后5 依次类推

5 5 6 7 8

最后发现没有j - 1, 就赋值 j 为 temp

```diff
                    // 如果蓝色指针指向 空
                    if (!arr[j - 1]) {
                        arr[j] = temp
                        break
                    }
```





## 归并排序

```diff
        // 时间复杂度 O(nlogN)
        // 归 - 归类 [3, 5, 1, 9, 4, 2, 11, 8]
        /* 
            3 5 1 9 | 4 2 11 8
            3 5 | 1 9 | 4 2 | 11 8
        */
	
	function mergeSort(arr) {
            let len = arr.length
            _mergeArr(arr, 0, len - 1)
        }
        
        // 合并数组
        function _mergeArr (arr, left, right) {
            // left - 左指针
            // right - 右指针

            // 退出
            if (left >= right) {
                return
            }
            // 求mid值
            let mid = parseInt((left + right) / 2)

            // 递归
            _mergeArr(arr, left, mid)
            _mergeArr(arr, mid + 1, right)
        }
```



