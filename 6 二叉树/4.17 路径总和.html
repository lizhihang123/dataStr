<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        function Node(val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
        var a = new Node(1)
        var b = new Node(null)
        var c = new Node(2)
        var d = new Node(3)
        var e = new Node(4)
        var f = new Node(5)
        var g = new Node(5)
        a.left = b
        a.right = c
        b.left = d
        b.right = e
        c.left = f
        c.right = g
        /* 
        1 时间O(n) n为节点个数 空间为O(n)n也是节点的个数
        2 核心思路: 一个数组存储数据，每次存[node，求和的值]
                   while循环，从栈里面弹出一个值，判断是不是叶子节点，并且它的求和的值是否是等于目标的值
                   不是 右节点有的话，入栈[节点值 + 上一个节点的pathSum]
                   左节点类推
                   好处：每个节点身上【都会携带当前节点和上一个父节点的值的和】
        */
        var hasPathSum = function (root, targetSum) {
            if (root === null) {
                return false
            }
            // 迭代
            let stack = []
            // [root, root.val] 这样存储很重要
            stack.push([root, root.val])
            // debugger
            let count = 0
            while (stack.length > 0) {
                // debugger
                // 中
                const [node, pathSum] = stack.pop()
                if (node.left === null && node.right === null && pathSum === targetSum) {
                    count++
                    return true
                    break
                }
                // 右
                node.right && stack.push([node.right, pathSum + node.right.val])
                // 左
                node.left && stack.push([node.left, pathSum + node.left.val])
            }
            return false
        }
        console.log(hasPathSum(a, 8));
    </script>
</body>

</html>