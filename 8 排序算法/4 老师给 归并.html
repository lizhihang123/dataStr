<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 归并排序的思路
        // 先归类 再排序 再合并
        // 

        // 主函数
        function mergeSort(arr) {
            var len = arr.length;
            _mergeSort(arr, 0, len - 1)
            return arr
        }

        // 分类的函数
        function _mergeSort(arr, left, right) {
            if (left >= right) {
                return;
            }
            debugger;
            // 利用left和right值 求出mid值 就是分类的基准值
            var mid = parseInt((left + right) / 2);

            // console.log('left', left, 'right', right)
            // 这里用作递归
            _mergeSort(arr, left, mid);
            _mergeSort(arr, mid + 1, right);
            _merge(arr, left, mid, right);
        }


        // 合并的函数
        function _merge(arr, left, mid, right) {
            // console.log('')
            var tempArr = [];
            var leftPoint = left;
            var rightPoint = mid + 1;
            debugger
            // if (arr[leftPoint] < arr[rightPoint]) {
            //     leftPoint ++;
            // } else {
            //     rightPoint ++;
            // }

            // 循环为 merge的总长度
            // 这里看不懂
            for (var i = 0; i < right - left + 1; i++) {
                // debugger;
                if (leftPoint > mid) {
                    tempArr.push(arr[rightPoint]);
                    rightPoint++;
                    continue;
                }

                if (rightPoint > right) {
                    tempArr.push(arr[leftPoint]);
                    leftPoint++;
                    continue;
                }

                if (arr[leftPoint] < arr[rightPoint]) {
                    tempArr.push(arr[leftPoint]);
                    leftPoint++;
                    continue;
                } else {
                    tempArr.push(arr[rightPoint]);
                    rightPoint++;
                    continue;
                }
            }

            tempArr.forEach((val, index) => {
                // console.log(i, value)
                arr[left + index] = val;
            });
            // debugger;

            // console.log(tempArr)
        }
        let initArr = [3, 5, 1, 9, 4, 2, 11, 8, 100, 99, 111]
        console.log(mergeSort(initArr));
        // let initArr2 = [5,1,1,2,0,0]
        // console.log(mergeSort(initArr2));
        // 根据上面的测试用例 来分析算法
        // 1. left = 0 mid = 2  right = 5
        // 2. 递归 left = 0 mid = 1 right = 2
        // 3. 递归 left = 0 mid = 0 right = 1
        // 4. 递归 left = 0 right = 0 return 上面走的都是merge的左半部分
        // 5. 走mergeSort右边  mid = 0 mid + 1 = 1 right = 1
        // 6. 递归mergeSort的左边 return 因为 left = 0 mid = 0 right = 0
        // 7. 就走merge
        // left = 0 mid = 0 right = 1
        // lP = 0 rP = 1
        // 循环比较 0 和 1索引的值[1]
        // 右指针越界 左指针放入 [1, 6]
        // 8. left = 0 mid = 1 right = 2
        // merge循环
        // lP = 0 rP = 2
        // 比较 0 与 2的值 [1]
        // 右指针越界 放入 1 [1, 1] [注意此时原本的arr的第一个值和第二个值都排序好了 可以按顺序放]
        // 右指针越界 放入 5 [1, 1, 5]
        // 9. left = 0 right = 5 mid = 2 传入 这里注意一下 会走一下递归右边 再走左边递归 意思是要切分右半边部分

        // ----------------------------------
        // [3, 5, 1, 9, 4, 2, 11, 8, 100, 99, 111]
        // 请注意 像这个数组的切分顺序 在上面的代码是
        // [3, 5, 1, 9, 4, 2] [11, 8, 100, 99, 111]
        // [3, 5, 1,][9, 4, 2]
        // [3, 5] [1]
        // [9, 4] [2]
        // 左半边排好了 再来右半边
        // [11, 8, 100] [ 99, 111]
        // [11, 8] [100]
        // [99, 111]

        // 排序的顺序是从里到外
        // [3, 5]
        // [3, 5] [1]
        // [9, 4]
        // [9, 4] [2]
        // [3, 5, 1,][9, 4, 2]
        // [11, 8]
        // [11, 8, 100]
        // [ 99, 111]
        // [11, 8, 100] [ 99, 111]
        // [3, 5, 1,][9, 4, 2] [11, 8, 100] [ 99, 111]

        // ----------------------------------
        // mergeSort右边 -》递归 mergeSort(arr, 2 + 1, 5) 意思是要切分右边一整块
        // mergeSort -》左边mergeSort(left, mid) -》切分为[3, 4] -》再切分[4, 4] -》 return
        // 10. [3, 4] -> 走merge 排序
        // 比较3 和 4索引的值 放入[0]
        // 越界，放入2 [0, 2]
        // 11. (3, 5) -> 走merge 排序
        // 比较3 和 5索引的值放入[0]
        // 越界 放入 0 [0, 0]
        // 越界 放入 2 [0, 0, 2]

        // 12. (0, 5)开始merge
        // 比较 0 与 3 [0]
        // 比较 0 与 4 [0, 0]
        // 比较 0 与 5 [0, 0, 1]
        // 比较 1 与 5 [0, 0, 1, 1]
        // 比较 2 与 5 [0, 0, 1, 1, 2]
        // 有一个越界 直接放入 [0, 0, 1, 1, 2, 5]
    </script>
</body>

</html>