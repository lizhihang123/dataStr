<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // https://www.bilibili.com/video/BV1MR4y1N7De?share_source=copy_web&vd_source=7149a850fbc1d6e85ac97c3e2372208c
        // 三路快排
        // 选基准值 如果选第一个的弊端就是
        // 如果是一个完全逆序的数组 要升序排列 就无法体现分治的思想

        // 双边循环法
        // 1 选定一个基准值 left指针从基准值开始[也可以是任意的]
        //   right从最右边开始
        //   right指针对应的值如果小于基准值，就停止 换 left移动 left指针对应的值如果大于基准值 就停止，交换left和right
        //   直到left和right指针相遇 要交换基准值和left指针的值
        //   还要修改startIndex
        //   这里的startIndex到底指向什么值

        // 单边循环法
        // 1 有一个基准值 pivot
        //   设置一个mark指针 指向数列的起始位置 -> 代表小于基准元素的区域边界
        //   遍历到的元素大于基准元素 往后遍历
        //   遍历到的元素小于基准元素
        //      mark指针右移一位 表示 小于基准元素的边界扩大了
        //      遍历到的元素和mark指针的元素交换位置

        /**
         * @name: 
         * @param {*} nums
         * @param {*} startIndex 起始下标
         * @param {*} endIndex 终止下标
         * @return {*}
         */
        //  let startIndex = Math.floor((nums.length - 1) / 2)
        //  let endIndex = nums.length - 1   
        function sortArray(nums) {
            debugger
            let startIndex = 0
            let endIndex = nums.length - 1
            quickSort(nums, startIndex, endIndex)
            return nums
        }
        function quickSort(nums, startIndex, endIndex) {
            // 递归退出条件
            if (startIndex >= endIndex) {
                return
            }
            // 得到基准元素位置
            debugger
            let pivotIndex = partition(nums, startIndex, endIndex)
            // 根据基准元素 分成两部分进行排序
            quickSort(nums, startIndex, pivotIndex - 1)
            quickSort(nums, pivotIndex + 1, endIndex)
        }

        function partition(arr, startIndex, endIndex) {
            debugger
            // 取第一个位置 也可以是随机的位置
            let pivot = arr[startIndex]
            let left = startIndex
            let right = endIndex

            while (left !== right) {
                // 控制right指针比较右移
                debugger
                while (left < right && arr[right] > pivot) {
                    right--
                }
                while (left < right && arr[left] <= pivot) {
                    left++
                }
                // 交换left和right所指向的元素
                if (left < right) {
                    let p = arr[left]
                    arr[left] = arr[right]
                    arr[right] = p
                }
            }
            // left指针和right指针重合了 就交换基准值和重合点的值
            arr[startIndex] = arr[left]
            arr[left] = pivot
            return left
        }
        // console.log(sortArray([5, 4, 3, 2, 1]));
        // console.log(sortArray([5, 1, 1, 2, 0, 0]));
        console.log(sortArray([5, 9, 7, 10, 3, 4]));
    </script>
</body>

</html>