<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>标题</title>
</head>

<body>
    <script>
        // 1 思路：像排队一样，从左 -> 右 升序。先找到最矮的，放到最左边第一个位置。第一个位置固定，从第二个位置开始，找到第二矮的，放到第二个位置。以此类推。每一轮选出最小的元素，交换到左侧的思路就是选择排序
        // 2 时间复杂度 O(n ^ 2) 因为两层for循环 外层的遍历次数是nums.length - 2 内层的遍历次数是num.length - 1 近乎理解为O(n ^ 2)
        // 3 空间复杂度 O(1) 是原地排序 没有使用额外的数组
        // 4 稳定排序? 不稳定，会改变 相同元素的相对顺序 
        // => 区别于冒泡排序，冒泡排序如果元素相同，不会进行交换 
        // => 当数组当中的元素大部分是有序时，冒泡排序的效率更高
        // => 而选择排序 无论如何，交换次数都是n-1
        function selectionSort(nums) {
            // i < nums.length - 1 不是 i < nums.length
            for (let i = 0; i < nums.length - 1; i++) {
                let minIndex = i
                // j < nums.length
                for (let j = i + 1; j < nums.length; j++) {
                    // 先找到最小的值的索引
                    if (nums[j] < nums[minIndex]) {
                        minIndex = j
                    }
                }
                // 如果最小值的索引和最初的i不一致 就要交换元素
                if (i !== minIndex) {
                    let temp = nums[i]
                    nums[i] = nums[minIndex]
                    nums[minIndex] = temp
                }
            }
            return nums
        }
        console.log(selectionSort([1, 2, 3, 3, 5, 5, 4, 2, 0]));
    </script>
</body>

</html>