<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 空间复杂度O(n)
        // 时间复杂度平均 O(nlogN) 最差是O(n ^ 2)
        function sortArray(nums) {
            // 关注一个问题 为啥这里长度为0要单独判断 直接返回arr不就好了?
            // 为了兼容 sortArray(leftArr).concat(targetNum, sortArray(rightArr)) 下面的一个递归的退出条件
            // 经过测试 下面两个情况都可以 只是 ===0 和 ===1区分开来 更加的清晰 更有逻辑性
            if (nums.length === 0) {
                return []
            }
            if (nums.length === 1) {
                return nums
            }
            // if (nums.length < 2) {
            //     debugger
            //     return nums
            // }
            

            // 基准 取第一个值会导致栈溢出 O(n ^ 2) 会超时
            // let targetNum = nums[0]
            // 取中间的值作为基准值
            let midIndex = Math.floor(nums.length / 2)
            let targetNum = nums[midIndex]
            // 这步 很关键 可以不用管那个目标值防止重复
            nums.splice(midIndex, 1)
            // 左边数组
            let leftArr = []
            // 右边数组
            let rightArr = []
            // 遍历
            // i = 1 改为 i = 0 因为取中间的值作为基准了
            for (let i = 0; i < nums.length; i++) {
                let num = nums[i]
                if (num > targetNum) {
                    rightArr.push(num)
                } else if (num <= targetNum) {
                    leftArr.push(num)
                }
            }
            let newArr = sortArray(leftArr).concat(targetNum, sortArray(rightArr))
            return newArr
        }
        // let test1 = [5, 4, 3, 2, 1]
        // let test2 = [10, 9, 8, 100, 11, 12]
        let test3 = [5,1,1,2,0,0]
        // console.log(sortArray(test1));
        // console.log(sortArray(test2));
        console.log(sortArray(test3));
    </script>
</body>
</html>