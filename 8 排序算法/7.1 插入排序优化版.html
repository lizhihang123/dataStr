<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1 优化的思路：把交换变成 “值的覆盖” 当后一个值小于前一个值时，不是每次都进行交换
        function insertSort(nums) {
            for (let i = 1; i < nums.length; i++) {
                // 把当前元素记忆
                let insertValue = nums[i]
                // j是上一个元素 当前元素和上一个元素进行比较
                let j = i - 1
                for (; j >= 0; j--) {
                    // 如果当前元素更小 就进行“赋值”操作
                    if (insertValue < nums[j]) {
                        nums[j + 1] = nums[j]
                    } else {
                        // “当前元素”比上一个元素大 就退出for循环比较
                        break
                    }
                }
                // “记忆的元素”赋值给nums[j+1]
                nums[j + 1] = insertValue
            }
            return nums
        }
        // console.log(insertSort([5, 2, 3, 1]));
        // console.log(insertSort([-4, 0, 7, 4, 9, -5, -1, 0, -7, -1])); // 这个测试用例无法通过

        // console.time('init1')
        // let initArr = [3, 5, 1, 9, 4, 2, 11, 8]
        // console.log(insertSort(initArr));
        // console.timeEnd('init1')

        // 采用赋值的形式 比直接交换 速度快了3倍
        let initArr = []
        for (let i = 10000; i > 0; i--) {
            initArr.push(i)
        }
        console.time('init1')
        console.log(insertSort(initArr));
        console.timeEnd('init1')

    </script>
</body>

</html>