<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>标题</title>
</head>

<body>
    <script>
        /* 
            1. 时间复杂度：O(n) / O(nlogn)
               平均情况下的时间复杂度O(n) 最坏情况下的时间复杂度O(nlogn)
               平均情况：假设n个元素需要排序 分为n个桶 每个桶里面一个元素
                - 求最大值和最小值 运算量为n
                - 创建空桶 运算量为n
                - 把原始数列的元素匹配到空桶里面 运算量为n
                - 在桶的内部做排序，在元素分布相对均匀的情况下，所有桶的运算量之和为n
                - 输出排序序列 -> 原始数组 运算量为n
                最终为O(n)
                最坏的情况：nlogn = nlogn[排序使用] + n = n (logn + 1) 而1可以忽略不计 就是nlogn

            2. 空间复杂度：O(n)
                - 一个空的数组 -> n
            
            3. 思路
                先规定每个桶里面有几个元素
                再根据最大值和最小值的差除以每个桶里面的元素数量向下取整 得到 几个桶
                把元素分别放进桶
                分别对每个桶里面的元素进行排序
                清空原始数组 + 把每个桶里面的排序好的元素拿出来 放到 原始的数组里面去

            4. 步骤    
                1 数据的最大值和最小值 
                2 先设定每个桶多少数据 + 结合每个桶的大小 算出需要多少个桶
                3 创建二维数组 + 数据按照桶分类放进去[怎么放是难点 这里的分类 桶和桶之间的大小已经有变化了 排序好的]
                4 每个桶里面的数据各自排序
                5 拍平数组 一个个取出来就行
        
        */
        function mergeSort(arr) {
            var len = arr.length;
            _mergeSort(arr, 0, len - 1)
            return arr
        }

        function _mergeSort(arr, left, right) {
            if (left >= right) {
                return;
            }
            debugger;

            var mid = parseInt((left + right) / 2);

            // console.log('left', left, 'right', right)
            _mergeSort(arr, left, mid);
            _mergeSort(arr, mid + 1, right);
            _merge(arr, left, mid, right);
        }

        function _merge(arr, left, mid, right) {

            // console.log('')

            var tempArr = [];
            var leftPoint = left;
            var rightPoint = mid + 1;
            debugger
            // if (arr[leftPoint] < arr[rightPoint]) {
            //     leftPoint ++;
            // } else {
            //     rightPoint ++;
            // }

            // 循环为 merge的总长度
            for (var i = 0; i < right - left + 1; i++) {
                // debugger;
                if (leftPoint > mid) {
                    tempArr.push(arr[rightPoint]);
                    rightPoint++;
                    continue;
                }

                if (rightPoint > right) {
                    tempArr.push(arr[leftPoint]);
                    leftPoint++;
                    continue;
                }

                if (arr[leftPoint] < arr[rightPoint]) {
                    tempArr.push(arr[leftPoint]);
                    leftPoint++;
                    continue;
                } else {
                    tempArr.push(arr[rightPoint]);
                    rightPoint++;
                    continue;
                }
            }

            tempArr.forEach((val, index) => {
                // console.log(i, value)
                arr[left + index] = val;
            });
            // debugger;

            // console.log(tempArr)
        }
        function bucketSort(arr, bucketSize) {
            // 最大值和最小值
            if (arr.length === 0) {
                return arr
            }
            let min = arr[0]
            let max = arr[0]
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] < min) {
                    min = arr[i] // 数组最小值
                } else if (arr[i] > max) {
                    max = arr[i] // 数据最大值
                }
            }
            // 桶的初始化

            // 每个桶的大小默认是5个数
            let default_bucket_size = 5
            bucketSize = bucketSize || default_bucket_size
            // 总共要几个桶 假设10个数 -> 最大值 99 最小值 89 -> 3个桶
            let bucketCount = Math.floor((max - min) / bucketSize) + 1
            // 创建3个空的桶
            let buckets = new Array(bucketCount)
            // 创建二维数组 [[], [], []]
            for (let i = 0; i < buckets.length; i++) {
                buckets[i] = []
            }
            // 利用映射关系 将数据分配到各个桶中[难点]
            for (let i = 0; i < arr.length; i++) {
                // [99, 98, 97, 96, 95, 94, 93.4, 92.3, 91.2, 90.1]
                buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i])
            }
            // 清空原本的数组
            arr.length = 0
            // 外层的数组
            for (let i = 0; i < buckets.length; i++) {
                mergeSort(buckets[i]) // 使用插入排序 对每个桶内部进行排序
                // 内层的数组
                for (let j = 0; j < buckets[i].length; j++) {
                    arr.push(buckets[i][j])
                }
            }
            return arr
        }
        console.log(bucketSort([99, 98, 97, 96, 95, 94, 93.4, 92.3, 91.2, 90.1]));
    </script>
</body>

</html>