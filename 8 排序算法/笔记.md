# 1. 冒泡排序

## 1 思路：

```diff
冒泡
1 时间复杂度O(n ^ 2) 空间复杂度O(1)
2 逻辑
  每个元素和后一个元素比较 当前一个大于后一个 进行交换【需要交换函数】
  每个元素都需要比较一波 => 外层循环是走len - 1次
  每个元素比较时，比的次数是 len - 1 - i次
  例子：
      5 - 1趟 每趟 5 - 1 - i次
      i = 0, 5 4 3 2 1[这次不算] => 4 5 3 2 1 => 4 3 5 2 1 => 4 3 2 5 1 => 4 3 2 1 5
      i = 1, 4 3 2 1 5[这次不算] => 3 4 2 1 5 => 3 2 4 1 5 => 3 2 1 4 5
      i = 2, 3 2 1 4 5[这次不算] => 2 3 1 4 5 => 2 1 3 4 5 
      i = 3, 2 1 3 4 5[不算] => 1 2 3 4 5
```



## 2 代码

```js
function swap (arr, index1, index2) {
    let temp = arr[index1] 
    arr[index1] = arr[index2]
    arr[index2] = temp
}
function BubbleSort(nums) {
    let len = nums.length
    for (let i = 0; i <= len - 1; i++) {
        for (let j = 0; j <= len - 1 - i; j++) {
            if (nums[j + 1] === undefined) {
                break
            }
            if (nums[j] > nums[j + 1]) {
                swap(nums, j, j + 1)
            }
        }
    }
    return nums
}
```

## 3 走过坑 

```diff
function swap (arr, index1, index2) {
    let temp = arr[index1] 
    arr[index1] = arr[index2]
    arr[index2] =  temp
+ 无需return arr 对数组的处理 就是引用传值即可
}
function BubbleSort (arr) {
    let len = arr.length
    // 注意 这里写 i = 0的目的是，外层排序多少次
    for (let i = 0; i < len - 1; i++) {
+                // 1. !坑 这里原本写 j = i 就排序不完
+                // 2. 为什么 j = 0呢? 
+                // 因为 [5, 1, 1, 2, 0, 0] 这个例子 5排序到最后面 5就不用动了 len - i 当i为1时，j的排序就少走一个 -》5不用动
+                // 3. 而[1,1,2,0,0,5] 此时1 和 0 比0 还是小的因此 索引为0的数字还是要排序 -> 推断 每次 j 都要从0开始
        for (let j = 0; j < len - i; j++) {
+                    // !坑 这里原本写 if(!arr[j + 1]) 这样写无法通过测试 因为 arr[j + 1] 有可能是 0 而 !0 就是true 就会break
            if (arr[j + 1] === undefined) {
                break
            }
+           // !坑 这里写 > 就是升序 写< 就是降序
            if (arr[j] > arr[j + 1]) {
                swap (arr, j, j + 1)
            }
        }
    }
    return arr
}
// console.log(BubbleSort([1, 2, 5, 333, 4, 8, 10, 9]));
// console.log(BubbleSort([5,1,1,2,0,0]));
console.log(BubbleSort([5,3,2,1]));
```









# 2 插入排序

## 1 思路

```js
时间复杂度O(n ^ 2)
空间复杂度O(1)
排序部分
1 插入排序可以用一种方式实现。
  两层循环，两个指针。
  假如长度为4的数组，j指向索引为2的元素，要和索引为1的元素比较，如果前面的大于后面的，就要交换元素。
  交换好后，j要递减，j - 1也会递减。再往前面去比较
2 需要两层循环
  外层 就是数组的长度
  内层 循环的次数 逐渐增加 i = 4 时，外层循环的次数就是4次

3 例子
i = 0, j = 0, 跳出循环 
i = 1, j = 1, 5 4 3 2 1 => 4 5 3 2 1 跳出循环
i = 2, j = 2, 4 5 3 2 1 => 4 3 5 2 1 => j = 1, 3 4 5 2 1  跳出循环
i = 3, j = 3, 3 4 5 2 1 => 3 4 2 5 1 => j = 2, 3 2 4 5 1 => j = 1, 2 3 4 5 1跳出循环
i = 4, j = 4, 2 3 4 5 1 => 2 3 4 1 5 => j = 3, 2 3 1 4 5 => j = 2, 2 1 3 4 5 => j = 1, 1 2 3 4 5 跳出循环
4 错误 曾经把内层的j的计数器 写成了++ 导致了时间超时
```

## 2 代码

```js
function swap (arr, index1, index2) {
    let temp = arr[index1] 
    arr[index1] = arr[index2]
    arr[index2] = temp
} 

function insertSort (nums) {
    if (nums.length < 2) {
        return nums
    }
    for (let i = 0; i < nums.length; i++) {
        for (let j = i; j > 0; j--) {
            if (nums[j - 1] > nums[j]) {
                swap(nums, j - 1, j)
            }
        }
    }
    return nums
}
```





## 3. 插入排序的优化



### 思路:

```diff
优化的方式是用排序
1 如果 j-1 的值 本身就小于j 的值 直接不动 continue 退出一层循环
2 如果 j-1 的值 大于 j的值 用temp 存储j的值
倒着去判断
	后面的值是否等于undefined[不能用!来进行判断 不然0会无法通过，坑] => 是 就赋值为temp
	后面的值是否小于temp的值 => 是 就赋值为temp
	如果都不是 就把 j - 1的值 赋值为 j的值
3 尤其注意 逻辑非在判断数字值时 要格外的注意

4 技巧：
	如果OJ上面排序前后没什么变化 | 如果说数字被覆盖了 排序后都是一个值 说明for循环或者while循环的条件出现问题
```



### 代码

```js
        function insertSort(nums) {
            for (let i = 0; i < nums.length; i++) {
                let iIndex = i
                let moveIndex = i - 1
                let temp = nums[i]
                if (nums[moveIndex] < nums[iIndex]) {
                    continue
                }
                for (let j = i; j > -1; j--) {
                    // 如果前一个数小于temp值 就把temp值放在nums[j]的位置
                    if (nums[j - 1] < temp) {
                        nums[j] = temp
                        break 
                    }
                    // 如果是第一个值 它的j - 1不存在 就让temp[j] 为temp值就好
                    // !如果这里的判断直接写!nums[j - 1] 就会出错
                    if (nums[j - 1] === undefined) {
                        nums[j] = temp
                        break 
                    }

                    nums[j] = nums[j - 1] // 如果都不满足 => 意味着不是第一个值 且 前一个值 大于临时变量 => 让后一个值等于前一个值
                }
            }
            return nums
        }
```







### 例子：

```js
		let initArr = [3, 5, 1, 9, 4, 2, 11, 8]
-------------------------------------------------------------------------
        i = 0
        3, 5, 1, 9, 4, 2, 11, 8 => 让 3 改为3 没什么变化
-------------------------------------------------------------------------
        i = 1 此时 3 < 5 continue
        3, 5, 1, 9, 4, 2, 11, 8
-------------------------------------------------------------------------
        i = 2, j = 2, temp = 1
        3, 5, 1[改为5], 9, 4, 2, 11, 8 -> arr[j] = arr[j - 1]
        j = 1
        3, 5[改为3], 5, 9, 4, 2, 11, 8 -> arr[j] = arr[j - 1]
        j = 0 
        3[改为1 = temp], 3, 5, 9, 4, 2, 11, 8 -> !arr[j - 1] arr[j] = temp

        此时 为 1, 3, 5, 9, 4, 2, 11, 8
-------------------------------------------------------------------------
        i = 3, j = 3, temp = 9
        5 < 9 continue 跳出循环
-------------------------------------------------------------------------
        i = 4, j = 4, temp = 4
        1, 3, 5, 9, 4[改为9], 2, 11, 8
        j = 3 
        1, 3, 5, 9[改为5], 9, 2, 11, 8
        j = 2
        因为 3 < 4[temp], 
        1, 3, 5[改为4], 5, 9, 2, 11, 8 => arr[j - 1] < temp, arr[j] = temp break
         此时为 1, 3, 4, 5, 9, 2, 11, 8
-------------------------------------------------------------------------
        i = 5, j = 5, temp = 2
        1, 3, 4, 5, 9, 2[改为9], 11, 8
        j = 4
        1, 3, 4, 5, 9[改为5], 9, 11, 8
        j = 3
        1, 3, 4, 5[改为4], 5 9, 11, 8
        j = 2
        1, 3, 4[改为3], 4, 5 9, 11, 8
        j = 1
        1, 3[改为2 = temp], 3, 4, 5 9, 11, 8 =>  arr[j - 1] < temp, arr[j] = temp break
        
        此时 1 2 3 4 5 9 11 8 胜利就在眼前
        
-------------------------------------------------------------------------     
        i = 6, j = 6, temp = 11
        9 < 11 continue
-------------------------------------------------------------------------
        i = 7, j = 7 temp = 8
        1 2 3 4 5 9 11 8[11]
        j = 6
        1 2 3 4 5 9 11[9] 11
        j = 5
        1 2 3 4 5 9[8 = temp] 9 11=>  arr[j - 1] < temp, arr[j] = temp, break
```



## 4 总结

插入排序

```js
1 第一个版本 就是后一个数 和 前一个数比较 如果前 > 后 就交换，同时要往前 j--
2 第二个版本 就是需要一个临时变量 temp = 索引[j] 的值
	前一个数 小于后一个数 continue
	前一个数 大于后一个数 要交换
    	如果索引[j - 1]值不存在 要让 索引[j]的值等于 临时变量的值
        如果索引[j - 1]值< temp,让索引[j]的值等于临时变量
		如果是大于临时变量，让j的值等于 索引[j - 1]
3 同时 视频里面说 优化版本减少交换 性能更好 但是放在OJ上面反而超时
没有优化的版本 不会超时 时间复杂度都是O(n ^ 2)
可以去掘进一下 插入排序的优化
```





# 3. 快速排序

## 写法1：

思路：找一个基准值，可以是中间，也可以是第一个。声明两个空数组，所有比他大的放右边，所有比他小的放左边。每个分块的内部，再进行同样逻辑的递归调用，用到了分治和递归的思想。

>原本疑惑，基准值本身怎么处置。有一个办法是直接删掉的同时记录[splice]，还有一个办法是写两个for循环，避开中间的基本值

```js
        // 空间复杂度O(n)
        // 时间复杂度平均 O(nlogN) 最差是O(n ^ 2)
        function sortArray(nums) {
            // 关注一个问题 为啥这里长度为0要单独判断 直接返回arr不就好了?
            // 为了兼容 sortArray(leftArr).concat(targetNum, sortArray(rightArr)) 下面的一个递归的退出条件
            // 经过测试 下面两个情况都可以 只是 ===0 和 ===1区分开来 更加的清晰 更有逻辑性
            if (nums.length === 0) {
                return []
            }
            if (nums.length === 1) {
                return nums
            }
            // if (nums.length < 2) {
            //     debugger
            //     return nums
            // }
            

            // 基准 取第一个值会导致栈溢出 O(n ^ 2) 会超时
            // let targetNum = nums[0]
            // 取中间的值作为基准值
            let midIndex = Math.floor(nums.length / 2)
            let targetNum = nums[midIndex]
            // 这步 很关键 可以不用管那个目标值防止重复
            nums.splice(midIndex, 1)
            // 左边数组
            let leftArr = []
            // 右边数组
            let rightArr = []
            // 遍历
            // i = 1 改为 i = 0 因为取中间的值作为基准了
            for (let i = 0; i < nums.length; i++) {
                let num = nums[i]
                if (num > targetNum) {
                    rightArr.push(num)
                } else if (num <= targetNum) {
                    leftArr.push(num)
                }
            }
            let newArr = sortArray(leftArr).concat(targetNum, sortArray(rightArr))
            return newArr
        }
        // let test1 = [5, 4, 3, 2, 1]
        // let test2 = [10, 9, 8, 100, 11, 12]
        let test3 = [5,1,1,2,0,0]
        // console.log(sortArray(test1));
        // console.log(sortArray(test2));
        console.log(sortArray(test3));
```

## 写法2：



```js
		function sortArray(nums) {
            let startIndex = 0
            let endIndex = nums.length - 1
            quickSort(nums, startIndex, endIndex)
            return nums
        }
        function quickSort (nums, startIndex, endIndex) {
            // 递归退出条件
            if (startIndex >= endIndex) {
                return 
            }
            // 得到基准元素位置
            debugger
            let pivotIndex = partition(nums, startIndex, endIndex)
            // 根据基准元素 分成两部分进行排序
            quickSort(nums, startIndex, pivotIndex - 1)
            quickSort(nums, pivotIndex + 1, endIndex)
        }   

        function partition (arr, startIndex, endIndex) {
            // 取第一个位置 也可以是随机的位置
            let pivot = arr[startIndex]
            let mark = startIndex
            for (let i = startIndex + 1; i <= endIndex; i++) {
                if (arr[i] < pivot) {
                    mark++
                    let p = arr[mark]
                    arr[mark] = arr[i]
                    arr[i] = p
                }
            }
            // 没有比当前基准值更小的元素 就交换当前的pivot的值 到mark上面去
            arr[startIndex] = arr[mark]
            arr[mark] = pivot
            return mark
        }
        console.log(sortArray([5, 1, 1, 2, 0, 0]));
```





## 写法3：

```js
function sortArray(nums) {
            let startIndex = 0
            let endIndex = nums.length - 1
            quickSort(nums, startIndex, endIndex)
            return nums
        }
        function quickSort (nums, startIndex, endIndex) {
            // 递归退出条件
            if (startIndex >= endIndex) {
                return 
            }
            // 得到基准元素位置
            debugger
            let pivotIndex = partition(nums, startIndex, endIndex)
            // 根据基准元素 分成两部分进行排序
            quickSort(nums, startIndex, pivotIndex - 1)
            quickSort(nums, pivotIndex + 1, endIndex)
        }   

        function partition (arr, startIndex, endIndex) {
            // 取第一个位置 也可以是随机的位置
            let pivot = arr[startIndex]
            let left = startIndex
            let right = endIndex

            while (left !== right) {
                // 控制right指针比较右移
                debugger
                while (left < right && arr[right] > pivot) {
                    right--
                } 
                while (left < right && arr[left] <= pivot) {
                    left++
                }
                // 交换left和right所指向的元素
                if (left < right) {
                    let p = arr[left]
                    arr[left] = arr[right]
                    arr[right] = p
                }
            }
            // left指针和right指针重合了 就交换基准值和重合点的值
            arr[startIndex] = arr[left]
            arr[left] = pivot
            return left
        }
        // console.log(sortArray([5, 4, 3, 2, 1]));
        console.log(sortArray([5, 1, 1, 2, 0, 0]));
```







# 5. 堆排序

## 1. 基础概念
- 完全二叉树:

倒数第二个节点以上，节点必须是满的

最后一行的节点，可以不满，但是如果有节点，都必须是靠左边的。、

![image-20220715081648431](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220715081648431.png)



- 最大堆或者是最小堆

最大堆，父节点的值一定比子节点的值要大

最小堆，父节点的值一定比子节点的值要小

![image-20220715081704258](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220715081704258.png)



堆排序一定满足是完全二叉树，一定是最大堆或者是最小堆



## 2. 如何存储

用数组来存储，

父节点的索引，i / 2 向下取整【i是子节点的索引】

左子节点的索引, i * 2【i是父节点的索引】

右子节点的索引，i * 2 + 1

![image-20220715080407329](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220715080407329.png)



## 3.  堆的操作

- 添加
- 删除



### 添加思路

只能在最底部添加元素，然后和父元素比较，如果比父元素大，就进行交换，直到没父元素大为止

![image-20220715081429670](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220715081429670.png)



### 删除思路

不能随意删除，只能删除堆顶。此时堆顶空了，需要把底部的元素挪上去。

父元素要和子元素进行比较，如果子元素更大，就进行交换。

如果子元素两个都比较大，就交换大的那个

![image-20220715081536400](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220715081536400.png)

![image-20220715081613977](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220715081613977.png)



## 4. 编码环节

### 走过的坑

1 为什么要设置数组第一个值是null

```diff
                为什么要设置一个null?
                    和堆的索引 第一个从1开始有关系
                为什么堆的索引要从1开始?
                和我们判断父节点 子节点有关系
                    如果索引从1开始 每个节点的父节点就是parseInt(i / 2)
                    每个节点的左子节点的索引就是 i * 2
                    右子节点的索引就是 i * 2 + 1
```



2 为什么添加元素一定是在底部添加

其他位置添加不好 会很混乱



3 维持堆顶状态的的while递归的条件搞错

while (this.data[currentIndex] > this.data[parseInt(currentIndex / 2 )] 



4 删除的思路 先交换索引为1的元素和最后一个 再进行向底下冒泡的过程

```diff
                swap(this.data, 1, this.data.length - 1)
                let result = this.data.pop()
                this.shiftDown(1)
                return result
```



5 删除的while 退出循环的条件搞错 只有当前元素小于子节点的值时，才需要退出

```diff
+         while (
                    // 需要 currentIndex的值 小于 左 或者 右子节点
                    this.data[currentIndex] < this.data[currentIndex * 2] ||
                    this.data[currentIndex] < this.data[currentIndex * 2 + 1]
                ) {
```



### 正式编码

```diff
        function swap (arr, index1, index2) {
            let temp = arr[index1] 
            arr[index1] = arr[index2] 
            arr[index2] = temp
        }
        class Heap {
            constructor() {
                // 为什么要设置一个null?
                    // 和堆的索引 第一个从1开始有关系
                // 为什么堆的索引要从1开始?
                // 和我们判断父节点 子节点有关系
                    // 如果索引从1开始 每个节点的父节点就是parseInt(i / 2)
                    // 每个节点的左子节点的索引就是 i * 2
                    // 右子节点的索引就是 i * 2 + 1
+                this.data = [null]
            }

            getData () {
                console.log(this.data)
                return this.data
            }

            // 添加
            insert (num) {
                // 最底部添加元素
+                this.data.push(num)
                // 维护顶部的状态
                this.shiftUp(this.data.length - 1)
            }

            // 维持堆顶状态 插入的元素要往上调整时
            shiftUp (currentIndex) {
                    // 递归 while循环 子元素 比父元素小 就交换
                    // currentIndex > 1 是为了避免第一个元素和null交换
+                while (this.data[currentIndex] > this.data[parseInt(currentIndex / 2 )] 
                && currentIndex > 1) {
                    swap(this.data, currentIndex, parseInt(currentIndex / 2))
                    // 改变当前指针的索引 为父元素
                    currentIndex = parseInt(currentIndex / 2)
                }
            }


            // 删除
            // 不能任意删除 将顶部和最后一个元素进行交换
                // 最后一个元素此时要进行和子元素比较 和较大的那个进行交换
            // 再删除最后一个元素
            extractMax () {
                swap(this.data, 1, this.data.length - 1)
                let result = this.data.pop()
                this.shiftDown(1)
                return result
            }

            // 维护顶层的元素
            shiftDown (currentIndex) {
+         while (
                    // 需要 currentIndex的值 小于 左 或者 右子节点
                    this.data[currentIndex] < this.data[currentIndex * 2] ||
                    this.data[currentIndex] < this.data[currentIndex * 2 + 1]
                ) {
                    // 如果右子节点 小于 左子节点
                    if (this.data[currentIndex * 2 + 1]  <  this.data[currentIndex * 2]) {
                        swap(this.data, currentIndex, currentIndex * 2)
                        currentIndex = currentIndex * 2
                    } else if (this.data[currentIndex * 2 + 1] > this.data[currentIndex * 2 ]) {
                        swap(this.data, currentIndex, currentIndex * 2 + 1)
                        currentIndex = currentIndex * 2 + 1
                    }
                }
            }
        }
        let heapData = new Heap()
        heapData.insert(1)
        heapData.insert(2)
        heapData.insert(3)
        heapData.insert(4)
        heapData.insert(5)
        heapData.getData()
        heapData.extractMax()
        heapData.getData()
```



## 5. 堆排序的正式编码

核心技巧：

```diff
            1. 堆的数据结构 
            2. 不断的把传入的数组里面的值放入堆
               借此生成了最大堆
               堆顶都是最大的元素
            3. 调用删除 取出最大堆的值
               unshift放入数组的前面部分
               输出这个值
```

踩过的坑

```diff
产生了一个死循环：
	if (this.data[currentIndex * 2 + 1]  <  this.data[currentIndex * 2]) {
        swap(this.data, currentIndex, currentIndex * 2)
        currentIndex = currentIndex * 2
+     } else if (this.data[currentIndex * 2 + 1] > this.data[currentIndex * 2]) {
        swap(this.data, currentIndex, currentIndex * 2 + 1)
        currentIndex = currentIndex * 2 + 1
    }
```



正式编码

```diff
function swap (arr, index1, index2) {
            let temp = arr[index1] 
            arr[index1] = arr[index2] 
            arr[index2] = temp
        }
        class Heap {
            constructor() {
                // 为什么要设置一个null?
                //     和堆的索引 第一个从1开始有关系
                // 为什么堆的索引要从1开始?
                // 和我们判断父节点 子节点有关系
                //     如果索引从1开始 每个节点的父节点就是parseInt(i / 2)
                //     每个节点的左子节点的索引就是 i * 2
                //     右子节点的索引就是 i * 2 + 1
                this.data = [null]
            }

            getData () {
                console.log(this.data)
                return this.data
            }

            // 添加
            insert (num) {
                // 最底部添加元素
                this.data.push(num)
                // 维护顶部的状态
                this.shiftUp(this.data.length - 1)
            }

            // 维持堆顶状态 插入的元素要往上调整时
            shiftUp (currentIndex) {
                    // 递归 while循环 子元素 比父元素小 就交换
                    // currentIndex > 1 是为了避免第一个元素和null交换
                while (this.data[currentIndex] > this.data[parseInt(currentIndex / 2 )] 
                && currentIndex > 1) {
                    swap(this.data, currentIndex, parseInt(currentIndex / 2))
                    // 改变当前指针的索引 为父元素
                    currentIndex = parseInt(currentIndex / 2)
                }
            }


            // 删除
            // 不能任意删除 将顶部和最后一个元素进行交换
                // 最后一个元素此时要进行和子元素比较 和较大的那个进行交换
            // 再删除最后一个元素
            extractMax () {
                swap(this.data, 1, this.data.length - 1)
                let result = this.data.pop()
                this.shiftDown(1)
                return result
            }

            // 维护顶层的元素
            shiftDown (currentIndex) {
                while (
                    // 需要 currentIndex的值 小于 左 或者 右子节点
                    this.data[currentIndex] < this.data[currentIndex * 2] ||
                    this.data[currentIndex] < this.data[currentIndex * 2 + 1]
                ) {
                    // 如果右子节点 小于 左子节点
                    if (this.data[currentIndex * 2 + 1]  <  this.data[currentIndex * 2]) {
                        swap(this.data, currentIndex, currentIndex * 2)
                        currentIndex = currentIndex * 2
+                    } else if (this.data[currentIndex * 2 + 1] > this.data[currentIndex * 2]) {
                        swap(this.data, currentIndex, currentIndex * 2 + 1)
                        currentIndex = currentIndex * 2 + 1
                    }
                }
            }
        }
        let initArr = [1, 2, 99, 10, 12, 87]
        function HeapSort (arr) {
            // 1. 堆的数据结构 
            // 2. 不断的把传入的数组里面的值放入堆
            //    借此生成了最大堆
            //    堆顶都是最大的元素
            // 3. 调用删除 取出最大堆的值
            //    unshift放入数组的前面部分
            //    输出这个值
            let heapData = new Heap()
            let resultArr = []
            arr.forEach(item => {
                heapData.insert(item)
            })
            for (let i = 0; i < arr.length; i++) {
+                let result = heapData.extractMax()
                resultArr.unshift(result)
            }
            return resultArr
        }
        console.log(HeapSort(initArr));
```



## 6. heapify()

```js
1 找到数组的 最后一个非叶子节点
2 最后一个非叶子节点 => parseInt( (数组的长度 - 1) / 2 )
3 为什么要从最后一个非叶子节点出发 因为叶子节点都只有一个节点 都可以理解为是最大堆 因此从非叶子节点触发
  而最后一个非叶子节点 的前面所有的节点 都需要调整 
4 判断此时是向上还是向下去调整 
  是向下 为什么 因此此时堆顶的元素是有问题的 要往下挪? 是上面的元素要往下 => 调用shiftDown即可
5 heapify(arr)的时间复杂度是O(n)
```

![image-20220716100853774](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220716100853774.png)







# 6. 计数排序

## 6.1 初级版



```js
// 1. 时间复杂度O(n ^ 2) ?
//    空间复杂度O(m)

// 2. 逻辑：给定一个数组 找到最大值 最大值 + 1 作为计数的数组
//    	   遍历原始的数组，计数的数组 -> 索引就是具体的数字，值就是个数
// 		   难点： 1 如何求出数组的长度 2 如何根据计数的数组 遍历得出原始的数组 -> 双层for循环 外层是原始数组的值 内层是这个值出现了几次
function sortArray(nums) {
            // 求数组的最大值
            let max = nums[0]
            let len = nums.length
            for (let i = 1; i < len; i++) {
                if (nums[i] > max) {
                    max = nums[i]
                }
            }
            // 根据最大值 求统计数组的长度
            // 数组的长度必须是最大值 + 1
            let countArray = new Array(max + 1).fill(0)
            // 遍历数列 填充统计数组
            for (let i = 0; i < len; i++) {
                // 怎么样把 [1, 2, 3] => 1 个 0; 2个1; 3个2输出出来
                countArray[nums[i]]++
            }
            let index = 0
            // 排序后的数组 长度和nums的一致
            let sortedArray = new Array(nums.length)

            // i 表示值是几
            // j 表示有几次循环 值出现了几次
            for (let i = 0; i < countArray.length; i++) {
                for (let j = 0; j < countArray[i]; j++) {
                    sortedArray[index++] = i
                }
            }
            return sortedArray
        }
        console.log(sortArray([1, 2, 2, 3, 4, 4, 5, 9, 9, 10, 10, 6, 7, 8]));
```





## 6.2 优化版本





```js
		/* 
            计数排序
        */
		// 1. 时间复杂度O(m + n)
		//	  空间复杂度O(m)

		// 2. 如果输入的数组是90 - 99之间的数字 最大值是99，就会创建99个元素，但是只用到10个，因此改为求最大最小值，的差 来创建计数的数组
		// 3. 如果99 93 94 94 95 
		//	  有两个值是一样的，并且值是有意义，比如两位同学的分数，希望这两个值能够也有先后的顺序 怎么做 这里是个难点
			  1 先把计数数组每一项和前面的求和
              2 小绿成绩95，找到countArray下标是元素5，值是4，表示小绿的成绩在第4位
              	同时 给countArray的下标是5的元素值-1，从4变成3，代表下次再遇见95分的成绩，最终排名是3
        function sortArray(nums) {
            // 1 求数组的最大值 最小值
            let max = nums[0]
            let min = nums[0]
            let len = nums.length
            for (let i = 1; i < len; i++) {
                if (nums[i] > max) {
                    max = nums[i]
                }
                if (nums[i] < min) {
                    min = nums[i]
                }
            }
            for (let i = 1; i < len; i++) {
                if (nums[i] > max) {
                    max = nums[i]
                }
            }
            let d = max - min
            debugger
            // 2 根据最大值最小值 求统计数组的长度
            // 数组的长度必须是最大值 + 1
            let countArray = new Array(d + 1).fill(0)
            // 遍历数列 填充统计数组
            for (let i = 0; i < len; i++) {
                // 怎么样把 [1, 2, 3] => 1 个 0; 2个1; 3个2输出出来
                countArray[nums[i] - min]++
            }
            debugger
            // 3 统计数组做变形 后面的元素等于前面的元素之和
            for (let i = 1; i < countArray.length; i++) {
                debugger
                countArray[i] += countArray[i - 1]
            }
            let index = 0
            debugger
            // 排序后的数组 长度和nums的一致
            // 4 倒序遍历原始的数组 从统计数组中找到正确的位置 输出到结果数组
            let sortedArray = new Array(nums.length)
            for (let i = nums.length - 1; i >= 0; i--) {
                debugger
                let num = countArray[nums[i] - min]
                sortedArray[num - 1] = nums[i]
                countArray[nums[i] - min]--
            }
            return sortedArray
        }
        console.log(sortArray([95, 94, 91, 98, 99, 90, 99, 93, 91, 92]));
```







## 6.3 缺点

1 数列最大和最小值差距很大时 不适合

2 不适合给小数排序





# 7. 桶排序







# 8. 希尔排序
