<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*         
        排序部分
        1 核心思路：
        类比打扑克牌：我们经常喜欢打顺子 -> 摸到一张牌9 会去跟前面的牌比较 如果原因的牌【排序好了的】里面，8比9小，我们就把9插入到8的前面，如果没有8只有7，就会把9插入到7的前面
        解释：把数组分为有序的和无序的两部分 把无序的数组的值和前面有序的数组进行比较 当无序的数组 遇见比自己小的值时，就插入到它的前面
        1 原本自己写的理解有偏颇：后一个数和前一个数进行大小的比较，如果前一个数比后一个数大，就进行交换
        且 随着i的递增，内层比较的次数会逐渐增加
        2 复杂度分析：
        时间复杂度：最坏情况为O(n ^ 2) 为什么？因为外层循环次数为n，内层循环次数每一轮 在最坏的情况下都是 1 2 3 4 直到 n - 1
        空间复杂度：是O(1) 是原地排序 没有借助第三方的空间 是原地排序
        3 是稳定的排序吗？

        */

        // 1 需要两个指针 
        //   指针B指向要交换的元素
        //   指针A指向比较的元素
        //   如果指针A的元素 比指针B的元素小,就要进行交换c
        // 2 需要两层循环
        //   外层 就是数组的长度
        //   内层 循环的次数 逐渐增加 i = 4 时，外层循环的次数就是4次

        // 3 例子
        // i = 0, j = 0, 跳出循环 
        // i = 1, j = 1, 5 4 3 2 1 => 4 5 3 2 1 跳出循环
        // i = 2, j = 2, 4 5 3 2 1 => 4 3 5 2 1 => j = 1, 3 4 5 2 1  跳出循环
        // i = 3, j = 3, 3 4 5 2 1 => 3 4 2 5 1 => j = 2, 3 2 4 5 1 => j = 1, 2 3 4 5 1跳出循环
        // i = 4, j = 4, 2 3 4 5 1 => 2 3 4 1 5 => j = 3, 2 3 1 4 5 => j = 2, 2 1 3 4 5 => j = 1, 1 2 3 4 5 跳出循环
        // 4 错误 曾经把内层的j的计数器 写成了++ 导致了时间超时

        let initArr = [3, 5, 1, 9, 4, 2, 11, 8]
        // 交换代码
        function swap(arr, index1, index2) {
            let temp = arr[index1]
            arr[index1] = arr[index2]
            arr[index2] = temp
            return arr
        }
        function insertSort(initArr) {
            // 边界情况
            // 无需考虑边界情况 因为 j是大于0的，而j-1是大于0的 
            // 考虑边界情况的一个思路，就是看遍历循环时，有没有可能让数组溢出
            // 以及考虑是否有空数组的情况存在

            let len = initArr.length
            // 如果数组只有一个元素 就不需要进行比较 直接返回即可
            if (len < 2) {
                return initArr
            }
            for (let i = 0; i <= initArr.length - 1; i++) {
                // ！j--不是j++
                for (let j = i; j > 0; j--) {
                    if (initArr[j - 1] > initArr[j]) {
                        debugger
                        swap(initArr, j - 1, j)
                    }
                }
            }
            return initArr
        }
        console.log(insertSort(initArr));
    </script>
</body>

</html>