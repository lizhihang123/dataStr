<!--
 * @Date: 2022-01-17 06:25:13
 * @LastEditTime: 2022-01-18 22:37:47
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 1. 法一： 暴力解法  没有通过 会超过时间限制
      // var rotate = function (nums, k) {
      //   if (nums.length <= 1) {
      //     return
      //   }
      //   while (k > 0) {
      //     nums.unshift(...nums.splice(-1, 1))
      //     k--
      //   }
      //   return nums
      // }
      // console.log(rotate([1, 2], 3))

      // 1.2
      // var rotate = function (nums, k) {
      //   if (nums.length <= 1) {
      //     return nums
      //   } else {
      //     // splice 先把前面的 [0, nums.length - k / nums.length] 值删除，返回值是删除的值，然后push到数组的后面
      //     nums.push(...nums.splice(0, nums.length - (k % nums.length)))
      //     return nums
      //   }
      // }
      // console.log(rotate([1, 2, 3], 3))

      // 2. 核心算法 先把原数组拷贝给一个临时数组 再利用 nums[j+k] % nums.length
      // var rotate = function (nums, k) {
      //   var tempArr = []
      //   var n = nums.length
      //   for (var i = 0; i < n; i++) {
      //     tempArr[i] = nums[i]
      //   }
      //   for (var j = 0; j < n; j++) {
      //     nums[(j + k) % n] = tempArr[j]
      //   }
      //   return nums
      // }
      // console.log(rotate([1, 2, 3, 4], 3))
      // console.log(rotate([1, 2, 3, 4], 5))
      // console.log(rotate([-1], 2))

      // 时间复杂度O(n)？
      // 一个计算从 0 加到 n 计算n次
      // 什么是O(1)
      // 一个计算 只需要计算一次 (n+1) / 2
      // 空间复杂度
      // 算法所需存储空间的大小
      // 谁更重要？
      // 冲突的情况下，以空间换时间。效率是更加重要的，存储空间越来越便宜

      // 3. 多次反转
      // var rotate = function (nums, k) {
      //   var n = nums.length - 1
      //   var temp = 0
      //   k = k % nums.length // 这句代码很关键 如果k > 数组长度 靠这个 来执行
      //   function reverse(nums, start, end) {
      //     while (start < end) {
      //       temp = nums[start]
      //       nums[start++] = nums[end]
      //       nums[end--] = temp
      //     }
      //   }

      //   // 先反转 全部 整个数组
      //   reverse(nums, 0, n)
      //   // 再反转 数组开头的k个数字
      //   reverse(nums, 0, k - 1)
      //   // 最后反转全部的【因为第一次反转过 这里还原一下】
      //   reverse(nums, k, n)
      //   return nums
      // }
      // console.log(rotate([1, 2, 3], 4))
    </script>
  </body>
</html>
