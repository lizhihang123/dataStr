# 1 数据结构是什么

## 概念

- 数据和数据之间的关系


  - 公司的子公司和母公司是母子关系


  - 类比公司部门和部门之间的关系，研发部门，运营部门，




- 数据结构的分类：

  - 按照逻辑分

    - 线性结构: 一对一。比如数组[1,2,3]，就是一对一

    - 非线性结构：一对多；比如DOM元素，body里面有很多内容，span，div盒子。body对应很多个子节点，dom树，树就是非线性结构。


  - 数据的存储方式：
    - 顺序存储
    - 散列存储
    - 链式存储：链表







# 2 时间复杂度

## **常数级别的操作是什么：**

​	比如加减乘除，比如比较大小



## 固定时间的操作

比如数组查询某一个索引的值，就是固定时间的操作。从逻辑上来看，数组的内存是连续的。尽管从实际来看，可能是不连续的。



链表的查找值，就是不固定时间的操作。

​	

## 大O表示法（BigO表示法）

**计数排序的推到**

![image-20221024103041471](https://typora-1309613071.cos.ap-shanghai.myqcloud.com/typora/image-20221024103041471.png)



**概念：**

如果将大O表示法 概括为，算法的执行次数，且是状况和运气最差的情况的执行次数。这样的准确度目前来说是够的。

一些常见的大O运行时间

```
O(1)
O(logn) 对数时间 包括二分查找
O(n) 线性时间，包括简单查找
O(n * logn) 快速排序
O(n^2) 选择排序 速度较慢
O(n!) 旅行商 速度非常慢
```

## O(1)：

如果一道算法里面没有循环和递归，那么再多行的代码，都只是O(1)

```js
function foo(){
    let n = 1
    let b = n * 100
    if(b === 100){
        console.log("开始吃糖")
    }
    console.log("我吃了1颗糖")
    console.log("我吃了2颗糖")
    ......
    console.log("我吃了10000颗糖")
}
```

## O(n): 

只有一层for循环或者递归

```js
function foo1(n){
    for( let i = 0; i < n; i++){
        console.log("我吃了一颗糖")
    }
}
function foo2(n){
    while( --n > 0){
        console.log("我吃了一颗糖")
    }
}
function foo3(n){
    console.log("我吃了一颗糖")
    --n > 0 && foo3(n)
}
```

## O(n ^ 2)：

双层for循环，外层一套 里层一套 都是执行n次

```js
function foo1(n){
    for( let i = 0; i < n; i++){
        for( let j = 0; j < n; j++){
            console.log("我吃了一颗糖")
        }
    }
}
```

## O(logn)：

log2 16 = 4 【2是底数，16是真数，4是对数】 2^4 = 16其中4就是对数

```js
function foo2(n){
    for(let i = 0; i < n; i *= 2){
        console.log("一天")
    }
}
foo2( 16 )
```

```js
function foo1(n){
    let day = 0
    while(n > 1){
        n = n/2
        day++
    }
    return day
}
console.log( foo1(16) ) // 4
```



## console.time

>O(n^2) 数据量大 直接让计算机卡住 是很明显的.
>
>O(n) 即便数据量 很大，计算机也不会特别的卡死

```js

console.time('forEach10000')
let count = 0
for (let i = 0; i < 10000; i++) {
    for (let j = 0; j < 10000; j++) {
        count = i + j
    }
}
console.timeEnd('forEach10000') // 192ms



console.time('forEach1000000')
let count1 = 0
for (let i = 0; i < 1000000; i++) {
    for (let j = 0; j < 1000000; j++) {
        count1 = i + j
    }
}
console.timeEnd('forEach1000000') // 直接让计算机卡住
```



```js
// 1. ES6的set结构 能够去除多余的NaN 但是多余的空对象没能够去除
// 时间复杂度是O(n)
var arr = [1, 1, 'true', 'true', true, true, 15, 15, false, false, undefined,
    undefined, null, null, NaN, NaN, 'NaN', 0, 0, 'a', 'a', {}, {}];
function unique_arr1(arr) {
    return [...new Set(arr)]
}
console.log(unique_arr1(arr));



let arr2 = []
for (let i = 0; i < 20000; i++) {
    arr2[i] = 1
}
console.time('indexOf')
// arr2.indexOf(20000)
console.log(unique_arr1(arr2));
console.timeEnd('indexOf') // 0.7ms

let arr3 = []
for (let i = 0; i < 20000000; i++) {
    arr3[i] = 1
}
console.time('indexOf2')
console.log(unique_arr1(arr3));
// arr2.indexOf(2000000)
console.timeEnd('indexOf2') // 357ms 是O(n)
```







## 递归的时间复杂度

求x^n次方



法1：

时间复杂度O(n)

```js
function fn (x, n) {
    let result = 1;
    for (let i = 0; i < n; i++) {
        result = result * x
    }
    return result
}
```



法2：

```js
function fn2 (x, n) {
    if (n === 0) {
        return 1
    }
    return fn2(x, n - 1) * x
}
```

递归算法的本质：不总是logN;而是 `递归的次数` 与 每次递归中 `操作次数的乘积`

每次递归n都做一次减1的操作，就是递归了n次。每次都进行一次乘法操作，乘法操作是O(1)

O(n) = O(n * 1)



法3：

类似一个二叉树 比如2的4次，会拆分为fn(2, 2) * fn(2 * 2) 这样就会有两个子节点，两个子节点又会列表

最终时间复杂度就是节点的个数，假如是2^3，最终就是执行O(n)就会

>存在疑惑 递归调用了几次 时间复杂度是多少 空间复杂度是多少

```js
function fn3(x, n) {

	if (n === 0) {
        return 1
    }
    if (n % 2 === 1) {
        return function3(x, n / 2) * function(x, n / 2) * x
    }
	return function3(x, n / 2) * function(x, n / 2)
}
```



法4：

时间复杂度O(logn) 因为递归被抽离了出来。且规模除以了2，就是logn，【此外里面每次都是乘法操作 是 O(1)】

```js
        function fn4(x, n) {
            console.log(1);
            if (n < 1) {
                return 1
            }
            let t = fn4(x, n / 2)
            if (n % 2 === 1) {
                return t * t * x
            }
            return t * t
        }
```





## 其它时间复杂度

<img src="D:/heima/front/7.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/datastr/0%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220719153419167.png" alt="image-20220719153419167" style="zoom:50%;" />



## 趋势

![未标题-3.jpg](D:/heima/front/7.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/datastr/0%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/6bce74e49bf84c44b1ba0f733ac4cc3etplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp)



## 插入排序的时间复杂度分析

```js
时间复杂度：最坏情况为O(n ^ 2) 为什么？因为外层循环次数为n，内层循环次数每一轮 在最坏的情况下都是 1 2 3 4 直到 n - 1
空间复杂度：是O(1) 是原地排序 没有借助第三方的空间
```



```js
// 1 核心思路 原本是每个 无序区的元素要回过头去和有序区的元素 一一比较，这样可能每个元素会被比较两次 => 不交换 用一个临时变量存储当前的值，把有序区的元素 从前向后逐步的往后复制 直到碰到了那个比自己小的值索引是j - 1，就把temp的值给到索引是j的地方
function insertSort(nums) {
// 1 如果 j-1 的值 本身就小于j 的值 直接不动 continue 退出一层循环
// 2 如果 j-1 的值 大于 j的值 用temp 存储j的值
// 倒着去判断
// 3 后面的值是否等于undefined[不能用!来进行判断 不然0会无法通过，坑] => 是 就赋值为temp
// 4 后面的值是否小于temp的值 => 是 就赋值为temp
// 5 如果都不是 就把 j - 1的值 赋值为 j的值

for (let i = 0; i < nums.length; i++) {
    let iIndex = i
    let moveIndex = i - 1
    let temp = nums[i]
    if (nums[moveIndex] < nums[iIndex]) {
        continue
    }
    for (let j = i; j > -1; j--) {
        if (nums[j - 1] < temp) {
            nums[j] = temp
            break
        }

        if (nums[j - 1] === undefined) {
            nums[j] = temp
            break
        }

        nums[j] = nums[j - 1]

    }
}
return nums
}
```



桶排序的时间复杂度分析

```js
1. 时间复杂度：O(n) / O(nlogn)
平均情况下的时间复杂度O(n) 最坏情况下的时间复杂度O(nlogn)
平均情况：假设n个元素需要排序 分为n个桶 每个桶里面一个元素
    - 求最大值和最小值 运算量为n
    - 创建空桶 运算量为n
    - 把原始数列的元素匹配到空桶里面 运算量为n
    - 在桶的内部做排序，在元素分布相对均匀的情况下，所有桶的运算量之和为n
    - 输出排序序列 -> 原始数组 运算量为n
最终为O(n)
最坏的情况：
	nlogn = nlogn[排序使用] + n = n (logn + 1) 而1可以忽略不计 就是nlogn

2. 空间复杂度：O(n)
- 一个空的数组 -> n
```

```js
        function mergeSort(arr) {
            var len = arr.length;
            _mergeSort(arr, 0, len - 1)
            return arr
        }

        function _mergeSort(arr, left, right) {
            if (left >= right) {
                return;
            }
            debugger;

            var mid = parseInt((left + right) / 2);

            // console.log('left', left, 'right', right)
            _mergeSort(arr, left, mid);
            _mergeSort(arr, mid + 1, right);
            _merge(arr, left, mid, right);
        }

        function _merge(arr, left, mid, right) {

            // console.log('')

            var tempArr = [];
            var leftPoint = left;
            var rightPoint = mid + 1;
            debugger
            // if (arr[leftPoint] < arr[rightPoint]) {
            //     leftPoint ++;
            // } else {
            //     rightPoint ++;
            // }

            // 循环为 merge的总长度
            for (var i = 0; i < right - left + 1; i++) {
                // debugger;
                if (leftPoint > mid) {
                    tempArr.push(arr[rightPoint]);
                    rightPoint++;
                    continue;
                }

                if (rightPoint > right) {
                    tempArr.push(arr[leftPoint]);
                    leftPoint++;
                    continue;
                }

                if (arr[leftPoint] < arr[rightPoint]) {
                    tempArr.push(arr[leftPoint]);
                    leftPoint++;
                    continue;
                } else {
                    tempArr.push(arr[rightPoint]);
                    rightPoint++;
                    continue;
                }
            }

            tempArr.forEach((val, index) => {
                // console.log(i, value)
                arr[left + index] = val;
            });
            // debugger;

            // console.log(tempArr)
        }
        function bucketSort(arr, bucketSize) {
            // 最大值和最小值
            if (arr.length === 0) {
                return arr
            }
            let min = arr[0]
            let max = arr[0]
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] < min) {
                    min = arr[i] // 数组最小值
                } else if (arr[i] > max) {
                    max = arr[i] // 数据最大值
                }
            }
            // 桶的初始化

            // 每个桶的大小默认是5个数
            let default_bucket_size = 5
            bucketSize = bucketSize || default_bucket_size
            // 总共要几个桶 假设10个数 -> 最大值 99 最小值 89 -> 3个桶
            let bucketCount = Math.floor((max - min) / bucketSize) + 1
            // 创建3个空的桶
            let buckets = new Array(bucketCount)
            // 创建二维数组 [[], [], []]
            for (let i = 0; i < buckets.length; i++) {
                buckets[i] = []
            }
            // 利用映射关系 将数据分配到各个桶中[难点]
            for (let i = 0; i < arr.length; i++) {
                // [99, 98, 97, 96, 95, 94, 93.4, 92.3, 91.2, 90.1]
                buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i])
            }
            // 清空原本的数组
            arr.length = 0
            // 外层的数组
            for (let i = 0; i < buckets.length; i++) {
                mergeSort(buckets[i]) // 使用插入排序 对每个桶内部进行排序
                // 内层的数组
                for (let j = 0; j < buckets[i].length; j++) {
                    arr.push(buckets[i][j])
                }
            }
            return arr
        }
        console.log(bucketSort([99, 98, 97, 96, 95, 94, 93.4, 92.3, 91.2, 90.1]));
```







总结:

1.算法的速度是什么? 是操作数的 增速

随着输入的增加，其运行时间将以什么样的速度增加



2.算法的运行时间用大O表示法表示

3.O(logn)  O(n) 快，当需要搜索的元素越多时，前者比后者快得多

4.大O表示法，不表示常量, O(n +26) 和 O(n - 26)   O(n / 26) 都表示为 O(n)







## 空间复杂度:

1 开辟数组 数组的长度就是空间复杂度

2 数组如果是二维的，空间复杂度是O(n ^2)

3 如果有递归 递归的深度就是空间复杂度

4 如果既有递归，又开辟了数组，递归的深度和数组的长度取最大的那个





只要不是因为算法执行导致额外空间出现，一万行也是O(1)

```js
function foo(){
    let n = 1
    let b = n * 100
    if(b === 100){
        console.log("开始吃糖")
    }
    console.log("我吃了1颗糖")
    console.log("我吃了2颗糖")
    ......
    console.log("我吃了10000颗糖")
}
```





n的数值越大，分配的空间也越多

```js
function foo(n){
    let arr = []
    for( let i = 1; i < n; i++ ) {
        arr[i] = i
    }
}
```





二维数组

```js
let arr = [
    [1,2,3,4,5],
    [1,2,3,4,5],
    [1,2,3,4,5]
]
```





# 3 数组

## 1. 汉诺塔规则

>每次只能移动一个长方形，并且大的长方形不能在小的长方形之上。

## 2. 汉诺塔的解题步骤

第一步

>递归：把第`n-1`个模块从 `塔1` 移动到 `塔2`
>输出语句 把第 `n` 个模块 从 `塔1` 移动到 `塔3`

第二步

>递归： 把`n-1`个模块 从`塔2`移动到`塔3`



```php
<?php
/*
 * @Date: 2021-10-27 13:09:06
 * @LastEditTime: 2022-01-09 22:09:54
 */
header('Content-type:text/html;charset=utf-8');
function hlt($a,$b,$c,$n)
{   
	// $n 表示有几个长方形
	// $a 表示第一个柱子
	// $b 表示第二个柱子
	// $c 表示第三个柱子
    static $cnt=1;
		if($n>1)
		{
			// n-1 个模块 从塔1移动到塔2
			hlt($a,$c,$b,$n-1);
		}
		if($n>0)
		{
			echo $a.'<-->'.$c.'第'.$cnt.'步</br>';
			$cnt++;
		}
	
		if($n>1)
		{
			//  n-1个模块 从塔2 移动到 塔3
			hlt($b,$a,$c,$n-1);
		}
		$n--;
	
}
hlt('A','B','C',3);
?>
```



## 3. 删除数组重复值

**题目描述【来自-右侧点击\**[力扣](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\**】：**

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

目标是：原地删除数组 重复出现的元素，每个元素只能出现一次。

返回值：删除后的数组的新长度。



注意点：

\1. 数组是有序的

\2. 数组里面的每个元素最终只有一个

\3. 不能声明新的数组，必须修改原数组



\1. 解法1，暴力解法

逻辑是：for循环 遍历，每个元素和下一个元素进行比较，如果说相等，就删除当前索引的元素。

技术点：1. while和for循环 2. 数组的splice方法（删除元素的索引，删除几个）

```javascript
      var removeDuplicates = function (nums) {
        for (var i = 0; i < nums.length; i++) {
          while (nums[i] === nums[i + 1]) {
            nums.splice(i, 1)
          }
        }
        console.log(nums)
        return nums.length
      }
      console.log(removeDuplicates([1, 2, 3, 4, 4, 4, 5, 5, 5]))
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

原有的写法和上面几乎一模一样，但是while 的地方写成了 if，就会无法完全实现。

能够通过的是[]1,2,3,3,4];

不能够通过的用例[1,2,3,3,3,4]; 只要重复的项大于等于3个，就会报错。

```javascript
      var removeDuplicates = function (nums) {
        for (var i = 0; i < nums.length; i++) {
          if (nums[i] === nums[i + 1]) {
            nums.splice(i, 1)
          }
        }
        console.log(nums)
        return nums.length
      }
      console.log(removeDuplicates([1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]))
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

原因在于，if写法，如下表格

| i                                                          | i+1  | nums[i] | nums[i+1] | nums原数组 splice以后                               |
| ---------------------------------------------------------- | ---- | ------- | --------- | --------------------------------------------------- |
| 0                                                          | 1    | 1       | 2         |                                                     |
| 1                                                          | 2    | 2       | 3         |                                                     |
| 2                                                          | 3    | 3       | 3         | [1,2,3,3,4,4,4,5,5,5]                               |
| 注意，上面一行执行，数组少了一个元素，索引对应的值会变化。 |      |         |           |                                                     |
| 3                                                          | 4    | 3       | 4         | 这里不会发生变化，跳过了第二个重复的3，问题出在这里 |

而用while

| i                                                            | i+1  | nums[i] | nums[i+1] | nums原数组 splice以后 |
| ------------------------------------------------------------ | ---- | ------- | --------- | --------------------- |
| 0                                                            | 1    | 1       | 2         |                       |
| 1                                                            | 2    | 2       | 3         |                       |
| 2                                                            | 3    | 3       | 3         | [1,2,3,3,4,4,4,5,5,5] |
| 注意，上面一行执行，数组少了一个元素，索引对应的值会变化。但是，while和if最大的差别是，while如果条件满足，仍旧会继续循环，不会马上跳出循环。索引 i 依旧为2，索引i+1 依旧为3，对应的值仍旧是3和3，再次执行删除操作。 |      |         |           |                       |



解法2: 数组设置两个指针。

其实我只学了js，没学过其它语言类似java和C语言，对于双指针这个解法有点懵，只能一个值一个值带进去理解代码。参见下面代码、表格和分析。

```javascript
      var removeDuplicates = function (nums) {
        let i = 0
        for (let j = 0; j < nums.length; j++) {
          if (nums[i] != nums[j]) {
            i++
            nums[i] = nums[j]
          }
        }
        return i + 1
      }
      
      console.log(removeDuplicates([1,2,3,4,4,5]))
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

| i                                                            | j    | nums[i] | nums[j] | i++后的 i  | i++后的 nums[i] | nums 替换后的数组 |
| ------------------------------------------------------------ | ---- | ------- | ------- | ---------- | --------------- | ----------------- |
| 0                                                            | 0    | 1       | 1       | 不执行后续 |                 |                   |
| 0                                                            | 1    | 1       | 2       | 1          | 2               | [1,2,3,4,4,5]     |
| 1                                                            | 2    | 2       | 3       | 2          | 3               | [1,2,3,4,4,5]     |
| 2                                                            | 3    | 3       | 4       | 3          | 4               | [1,2,3,4,4,5]     |
| 3                                                            | 4    | 4       | 4       | 不执行后续 |                 |                   |
| 3                                                            | 5    | 4       | 5       | 4          | **4**           | **[1,2,3,4,5,5]** |
| 如上，最终返回的是i+1,也就是标红色的4+1，数组里面1,2,3,4,5有五个不重复的数字，最后一个5就无需管它。i 这里就像是计数符 |      |         |         |            |                 |                   |



还有一个写法

小伙伴可以去自行测试，但是写法2的时间和空间复杂度是最低的！！

```javascript
var removeDuplicates = function (nums) {
        let i = 0
        for (let j = 0; j < nums.length; j++) {
          if (i < 1 || nums[i - 1] != nums[j]) {
            nums[i] = nums[j]
            i++
          }
        }
        return i
      }
      console.log(removeDuplicates([1, 3, 3, 4, 4, 5]))
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

参考了这篇文章，感谢他给了我思路，让我能够看懂。[力扣：删除排序数组中的重复项js版 - 掘金](https://juejin.cn/post/6844903942388711432)



## 4. 买卖股票

price[i]给定的一支股票





## 5. 旋转数组k步

思路1：最后一个数pop，然后放到最前面去，旋转几步，就放几次

思路2：旋转k步，就截取最后k个数，然后前面的数也截取出来，后 + 前 利用concat方法



**思路1**

```js
function rotate(arr, k) {
  // 排除意外的情况
  if (!k || arr === []) return arr
  // 如果k超过了arr的长度 我们也能够进行遍历修改
  let step = Math.abs(k % arr.length)
  for (let i = 0; i < step; i++) {
    // 把最后一个数取出来 放到最前面 step有几个，就取几个
    // 如果说长度是4，但是k是5，那么5%4其实就是1
    let num = arr.pop()
    if (num) {
      arr.unshift(num)
    }
  }
  return arr
}
// console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
console.log(rotate([1, 2, 3, 4], 5));
```



**思路2：**使用双指针，进行反转。

先反转整个数组，再反转前k个，再反转后面的数字。

![image-20221104085753445](https://typora-1309613071.cos.ap-shanghai.myqcloud.com/typora/image-20221104085753445.png)

```js
// 时间复杂度O(n)
// 空间复杂度O(1)
// reverse方法
var rotate = function (nums, k) {
  let n = nums.length
  // k是null 0 undefined之类
  if (n === 0 || !k) {
    return nums
  }
  // k如果大于长度
  k = k % n
  function reverse(nums, i, j) {
    while (i < j) {
      // 解构赋值 进行交换
      [arr[i], arr[j]] = [arr[j], arr[i]]
      i++
      j--
    }
  }
  if (k) {
    // 反转整个数组
    reverse(nums, 0, n - 1)
    // 反转前k个数
    reverse(nums, 0, k - 1)
    // 反转后续的所有数
    reverse(nums, k, n - 1)
  }
  return nums
};
console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(rotate([1, 2, 3, 4], 5));
```



## 8. 移动0

## 法一：

> 法一 碰到0 不移动 碰到不是0的 就往前挪动 然后把后面的都变成0

```
var moveZeroes = function (nums) {
        if (nums.length === 0) {
          return
        }
        let index = 0
        for (let i = 0; i < nums.length; i++) {
          if (nums[i] != 0) {
            nums[index++] = nums[i]
          }
        }
        while (index < nums.length) {
          nums[index++] = 0
        }
        return nums
      }
      console.log(moveZeroes([1, 0, 2, 0, 3, 0, 4]))
      console.log(moveZeroes([]))
      console.log(moveZeroes([1, 0, 0]))
      console.log(moveZeroes([1, 0, 0, 2]))
```

| i    | index                     | nums[i] | nums[index++] | nums        |
| ---- | ------------------------- | ------- | ------------- | ----------- |
| 0    | 0                         | 0       | 0             | [0,1,0,3,2] |
| 1    | 0                         | 1       | 1             | [1,1,0,3,2] |
| 2    | 1                         | 0       | 1             | [1,1,0,3,2] |
| 3    | 1                         | 3       | 3             | [1,3,0,3,2] |
| 4    | 2【下一个是3 跳出了循环】 | 2       | 2             | [1,3,2,3,2] |

最后while循环 此时Index等于3

nums[1,3,2,3,2]索引3，4的都变成0  就是[1,3,2,0,0]

## 法二：

>  // 2. 双指针 交换变量
>  // 如果说一个数字是非0 就使劲往前靠 总是可以跑到前面去

```
      var moveZeroes = function (nums) {
        let i = 0
        let temp = 0
        for (let j = 0; j < nums.length; j++) {
          if (nums[j] !== 0) {
            temp = nums[i]
            nums[i] = nums[j]
            nums[j] = temp
            i++
          }
        }
        return nums
      }
      console.log(moveZeroes([1, 2, 0, 0, 3, 2, 0]))
```



| i    | j    | nums[j] | nums[i] | temp | nums[i] | nums[j] | nums        |
| ---- | ---- | ------- | ------- | ---- | ------- | ------- | ----------- |
| 0    | 0    | 不执行  |         |      |         |         |             |
| 0    | 1    | 1       | 0       | 0    | 1       | 0       | [1,0,0,3,2] |
| 1    | 2    | 不执行  |         |      |         |         |             |
| 1    | 3    | 3       | 0       | 1    | 3       | 1       | [1,3,0,0,2] |
| 2    | 4    | 2       | 0       | 0    | 2       | 0       | [1,3,2,1,0] |
|      |      |         |         |      |         |         |             |



## 9. 两数之和



法二：借助对象

>   // 逻辑：target - nums[i] 的结果 与 i的索引绑定，存到对象里面，
>
>   // 如果后面的num[i]有这个值，说明 表示 nums[i] + target - nums[i] = target 正中下怀 取到此时的i 和 当时的索引在obj对象里面查找，就是当前 的obj[nums[i]]键对应的值

```
      var twoSum = function (nums, target) {
        var obj = {}
        for (var i = 0; i < nums.length; i++) {
          if (typeof obj[nums[i]] !== "undefined") {
            return [obj[nums[i]], i]
          }
          obj[target - nums[i]] = i
        }
      }
      console.log(twoSum([1, 2, 3, 4, 6], 7))
```

| i    | nums[i] | obj[nums[i]] | target - nums[i] | obj[target-nums[i]] | obj               |
| ---- | ------- | ------------ | ---------------- | ------------------- | ----------------- |
| 0    | 1       | undefined    | 7                | 0                   | {7:0}             |
| 1    | 2       | undefined    | 6                | 1                   | {7:0,6:1}         |
| 2    | 3       | undefined    | 5                | 2                   | {7:0,6:1,5:2}     |
| 3    | 4       | undefined    | 4                | 3                   | {7:0,6:1,5:2,4:3} |
| 4    | 5       | 有值         | 3                | 4                   | {7:0,6:1,5:2,4:3} |

目标 8 数组是[1,2,3,4,5] 

结果返回 [obj[nums[i]],4]  i此时为4，nums[4]为5，obj[5]对应的值是2，所以返回[2,4]





## 10. 有效的数独

逻辑：

横着的 是一个数组

竖着的是一个数组

九宫格是一个数组 九宫格的索引一次为 0 1 2 3 4 5 6 7 8

```js
        // 1. 执行成功 但是 时间复杂度很高
        var isValidSudoku = function (board) {
            let col = {}
            let row = {}
            let box = {}
            for (var i = 0; i < board.length; i++) {
                for (var j = 0; j < board[i].length; j++) {
                    let num = board[i][j];
                    if (num !== '.') {
                        // i是行的索引
                        // j是列的索引
                        // boxindex 九宫格的索引
                        let boxindex = Math.floor(i / 3) * 3 + Math.floor(j / 3)
                        if (col[i + '' + num] || row[j + '' + num] || box[boxindex + '' + num]) {
                            //上面代码的意思是，如果col或者row或者box对象里面有这个数，就返回false
                            return false
                        }
                        // 如果没有这个数，就存到对象里面去
                        col[i + '' + num] = true;
                        row[j + '' + num] = true;
                        box[boxindex + '' + num] = true;
                        debugger
                    }
                }
            }
            return true
        }
        var arr1 = [
            ["5", "3", ".", ".", "7", ".", ".", ".", "."],
            ["6", ".", ".", "1", "9", "5", ".", ".", "."],
            [".", "9", "8", ".", ".", ".", ".", "6", "."],
            ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
            ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
            ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
            [".", "6", ".", ".", ".", ".", "2", "8", "."],
            [".", ".", ".", "4", "1", "9", ".", ".", "5"],
            [".", ".", ".", ".", "8", ".", ".", "7", "9"]]
        var arr2 = [
            ["1", "0", ".", ".", ".", ".", ".", ".", "."],
            ["1", ".", ".", "1", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."]
        ]
        var arr3 = [
            ["1", "1", ".", ".", ".", ".", ".", ".", "."],
            ["0", ".", ".", "1", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."],
            [".", ".", ".", ".", ".", ".", ".", ".", "."]
        ]
        console.log(isValidSudoku(arr2));
```



假设数据如上面所示 arr3

boxindex=Math.floor(i / 3) * 3 + Math.floor(j / 3)  

| i    | j    | num  | boxindex | row                                                          | col                                     | box                                   |
| ---- | ---- | ---- | -------- | ------------------------------------------------------------ | --------------------------------------- | ------------------------------------- |
| 0    | 0    | 1    | 0        | {01: true} 前面的key 0表示第0行，1表示这个数是0              | {01: true}key01的0表示第0列，1表示数是1 | {01:false}key01表示第0个九宫格，数是0 |
| 0    | 1    | 1    | 0        | {01: true,}本来应该存这个数据到row数组，发现有这个数了，就returnfalse |                                         |                                       |
|      |      |      |          |                                                              |                                         |                                       |

假设数据如上面所示 arr2所示

boxindex=Math.floor(i / 3) * 3 + Math.floor(j / 3)  

| i    | j    | num  | boxindex | row        | col                                                   | box        |
| ---- | ---- | ---- | -------- | ---------- | ----------------------------------------------------- | ---------- |
| 0    | 0    | 1    | 0        | {01: true} | {01: true}                                            | {01:false} |
| 1    | 0    | 1    | 0        | {11: true} | {01：true} 本来应该插入这个数，发现有了就return false |            |





方法二非常多的for循环

```
 var isValidSudoku = function (board) {
            var flag = 0;
            // 行和列的比较
            // 三层for循环 z + 1
            for (var i = 0; i < 9; i++) {
                for (var j = 0; j < 9; j++) {
                    for (var z = j + 1; z < 9; z++) {
                        // 行 上的元素比较 第一个都是i表示都一行
                        if (board[i][j] != '.' && board[i][j] === board[i][z]) {
                            flag = 1;
                            return false
                        }
                        // 列 上的元素比较 第二个都是i表示都一列
                        if (board[j][i] != '.' && board[j][i] === board[z][i]) {
                            console.log(board[j][i]);
                            console.log(board[z][i]);
                            flag = 1;
                            return false
                        }
                    }
                }
            }

            for (var row = 0; row < 9; row += 3) {
                for (var col = 0; col < 9; col += 3) {
                    var num = []
                    for (var a = 0; a < row.length; a++) {
                        for (var b = 0; b < row.length; b++) {
                            if (board[a][b] !== ".") {
                                num.push(board[a][b])
                                console.log(num);
                            }
                        }
                    }
                    for (var x = 0; x < num.length; x++) {
                        for (var y = x + 1; y < num.length; y++) {
                            console.log(nums[i], nums[j]);
                            if (num[x] === num[y]) {
                                flag = 1;
                                return false
                            }
                        }
                    }
                }
                if (flag === 0) {
                    return true
                }
            }
        }1
```

row col a b board[a][b] num

| row  | col  | a    | b    | board [a] [b] | num  |
| ---- | ---- | ---- | ---- | ------------- | ---- |
| 0    | 0    | 0    | 0    | 1             | [1]  |
| 0    | 0    | 0    |      |               |      |
|      |      |      |      |               |      |
|      |      |      |      |               |      |



有效的数独：

https://www.jianshu.com/p/6598e558865b

https://blog.csdn.net/qq_38200548/article/details/80865681

https://juejin.cn/post/7031010357334245390

https://juejin.cn/post/7029566071141040158







11.翻转图像

- for循环两次 上下翻转 -> 沿着对角线翻转

```js
var rotate = function(matrix) {
            const n = matrix.length;
            let temp_a = 0;
            let temp_b = 0;
            // 上下旋转
            for (var a = 0; a < n / 2; a++) {
                console.log(matrix[a]);
                temp_b = matrix[a];
                matrix[a] = matrix[n - a - 1];
                matrix[n - a - 1] = temp_b
            }
            // 对角线旋转
            for(var i = 0; i < n; i++) {
                for(var j = i + 1; j < n; j++) {
                    temp_a = matrix[i][j];
                    matrix[i][j] = matrix[j][i]
                    matrix[j][i] = temp_a
                }
            }
            return matrix;
};
```

```
        console.log(rotate([
            [1,2,3],
            [4,5,6],
            [7,8,9]
        ]));
        console.log(rotate([
            [13,14,12,10],
            [13,3,6,7],
            [2,4,8,10],
            [15,1,9,11]
        ]));
```

>比如 11要翻到15，如果最终通过对角线，先要到10，，再要到15，因此要先对行翻转

matrix[0] 与 matrix[2] 先翻转

如果是四阶

martix[0] 与  matrix[3]先

martix[1] 与 matrix[2] 先

核心：

```
                matrix[a] = matrix[n - a - 1];
```



紧接着 沿着对角线翻转:



| i    | j    | temp | matrix [i] [j] | martix [j] [x] | temp |
| ---- | ---- | ---- | -------------- | -------------- | ---- |
| 0    | 1    |      | <-14           | <-13           | <-14 |
| 0    | 2    |      | <-12           | <-2            | <-12 |
| 0    | 3    |      | <-10           | <-5            | <-10 |
| 1    | 2    |      | <-6            | <-4            | <-6  |
| 1    | 3    |      | <-7            | <-1            | <-7  |
| 2    | 3    |      | <-10           | <-9            | <-10 |



- 法2：

```js
    // 时间复杂度非常好
    // 逻辑就是外层到内层 分别进行顺时针旋转 直接旋转
    // 核心是 交换两个变量的值
```

```
  var rotate = function(ma) 

        {
            let le = ma.length;
            var temp = 0;
            var m = 0;
            var n = 0;
            for(var i = 0; i < le / 2; i++) {
                for(var j = i; j < le - i - 1; j++ ) {
                    m = le - j - 1;
                    n = le - i -1;
                    temp = ma[i][j]
                    ma[i][j] = ma[m][i]
                    ma[m][i] = ma[n][m]
                    ma[n][m] = ma[j][n]
                    ma[j][n] = temp
                }
            }
            return ma
        }
```

注意语法1：

j=i 且 j < le - i - 1

注意语法2：

                    m = le - j - 1;
                    n = le - i -1;

注意语法3：

                    temp = ma[i][j]
                    ma[i][j] = ma[m][i]
                    ma[m][i] = ma[n][m]
                    ma[n][m] = ma[j][n]
                    ma[j][n] = temp

如下代码为例

```
        console.log(rotate(
            [
            [13,14,12,10],
            [13,3,6,7],
            [2,4,8,10],
            [5,1,9,11]
            ]
        ));
```

| i    | j    | length - i - 1 | temp | m    | n    | ma [i] [j] | ma [m] [i] | ma [n] [m] | ma [j] [n] | temp |
| ---- | ---- | -------------- | ---- | ---- | ---- | ---------- | ---------- | ---------- | ---------- | ---- |
| 0    | 0    | 3              | 13   | 3    | 3    | 13         | 5          | 11         | 10         | 13   |
| 0    | 1    | 3              | 2    | 2    | 3    | 14         | 2          | 9          | 7          | 2    |
| 0    | 2    | 3              | 12   | 1    | 3    | 12         | 5          | 14         | 12         | 3    |
| 1    | 1    | 2              | 3    | 2    | 2    | 3          | 4          | 6          | 8          | 3    |

首先是最外层的顺时针旋转90度

最后是最内层的顺时针旋转



## 11. 旋转图像







# 4 字符串

## 1. 反转字符





## 2. 反转整数

解法一：求余 向下取整

```js
var reverse = function(x) {
    let ord = Math.abs(x) // 取绝对值
    let now = 0
    while(ord > 0) {
        now = now * 10 + ord % 10
        ord = Math.floor(ord / 10)
    }
    if(x >= 0) {
        return now < Math.pow(2,31) - 1 ? now : 0
    } else if (x < 0) {
        return -now > -Math.pow(2,31) ? -now : 0
    }
}
console.log(reverse(1234));
console.log(reverse(-1234));
console.log(reverse(-11112222333344445555));
console.log(reverse(1534236469));
```

关键代码

```js
    while(ord > 0) {
        now = now * 10 + ord % 10
        ord = Math.floor(ord / 10)
    }
```

当x=1234时

|        | now            | ord                    |
| ------ | -------------- | ---------------------- |
| 第一次 | 0*10+1234%10=4 | 1234 / 10 向下取整 123 |
| 第二次 | 43             | 12                     |
| 第三次 | 432            | 1                      |
| 第四次 | 4321           | 0                      |



限制范围代码

```js
    if(x >= 0) {
        return now < Math.pow(2,31) - 1 ? now : 0
    } else if (x < 0) {
        return -now > -Math.pow(2,31) ? -now : 0
    }
```

易错点：

- 反转后的数字有范围限制
- now记得添加负号
- 负数Math.pow(2,31) 添加负号
- x=0的情况要考虑

解法二：





## 10. KMP算法



## 10.1 什么是KMP算法？用来解决什么问题？

1. KMP算法是什么：

​	思想：主串与模式串匹配的问题，当字符串出现不匹配的情况时，可以知道一部分已经匹配的内容，利用这些信息避免从头再去匹配



2. 核心：

​	如何记录已经匹配的内容是KMP算法的重点， next数组肩负的重任。next是前缀表的变形





3. 为什么要用前缀表？

​	因为**前缀表**：用来**回退**，记录了模式串与主串不匹配的时候，**模式串应该从哪里开始匹配**。【一旦匹配失败，下一步模式串从哪里开始匹配】。

​	**前缀表**： 记录**下标i之前包括i**，有多大长度的**相同前缀和后缀**



4. 为什么最长相等前缀后缀的内容 可以作为回退的依据呢？

本质就是：我们忽略最长相等的前缀，从他的后面开始

```diff
aabaacd
aabaaf
c和f冲突，我们忽略前面的aa，从主串的b开始。“主串”的'aa'子串我们已经试过了，这个对我们子串不管用，pass
```





5. 前缀是什么？后缀是什么？

​	主串：aabaabaaf

​	子串：aabaaf

​	比如上面的子串的**前缀**【不包括最后一个字符的子串】=》a、aa、aab、aaba、aabaa

​	**后缀**【不包括第一个字符的子串】 =》 f、af、aaf、baaf、abaaf



6. 最长相等前缀后缀？前缀表？

```diff
从aabaaf得出最长相等前缀后缀 =》前缀表

a => 0

aa => 1 【首尾都是a】

aab=> 0 【首是a 尾是b】

aaba=> 1

aabaa =>2

aabaaf => 0

前缀表是 010120

aabaabaaf

aabaaf

010120
```



上面的匹配过程中，当f和b冲突时，我们看f前一位对应的`前缀表`的值是2，说明我们要让主串回退到索引为2的值，正好是b



7. `如何定义一个next数组？`

```
构造next数组其实就是计算模式串s前缀表的过程。 
```

时间复杂度O(m) m是子串的长度，虽然里面有while循环，但是while循环的回退，根据的是next指针进行变化，时间复杂度很小近乎O(1)

```js
const getNext = (needle) => {
    // 初始化
    let next = [];
    let j = 0;
    next.push(j);
	// for循环，i在j的后面
    for (let i = 1; i < needle.length; ++i) {
        // 前缀和后缀不相等的情况
        // 用while 不用if 因为要一直回退 不能半途而废
        while (j > 0 && needle[i] !== needle[j]) {
            j = next[j - 1];
        }
        // 前缀和后缀相等的情况
        if (needle[i] === needle[j]) {
            j++;
        }
        next.push(j);
    }

    return next;
}
```

8. 整体代码：









## 11. 外观数列

js

```
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    let str = '';//临时保存的值
    let string = '';//需要返回的值
    let count = 0;//某个数字的个数
    let num = '';//当前位置的数字
    for(let i = 0;i < n;i++){
        if(i==0){ //指为n为1时，将返回值置为1
            str = '1';
            string = str;
        }else{ //n大于1时执行的代码
            str = ''; //保存每次的结果，初始为空
            for(let j = 0;j < string.length;j++){
                if(num == ''){
                    num = string[j];
                }
                if(num != string[j]){
                    str += `${count}`+num;
                    num = string[j];
                    count = 1;
                }else{
                    count++;
                }
            }
            string = str + `${count}` + num;
            num = '';
            count = 0;
        }
    }
    return string;
};

作者：Houwx
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnpvdm/?discussion=dWGyJ1
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





## 12. 最长相等前缀和后缀

```
            1. 先判断数组的长度 如果为1 就return它自身？
            2. 声明变量 index 用于指向每个字符的内部
               声明变量 str 代表数组的第一个值
               flag变量 判断是否要return 如果for循环当前跳出了 while循环也应当跳出
            3. 外层while循环 index小于第一个值的长度
               内层for循环 遍历数组后续的每一个值
               如果不等 str[index] !== strs[i][index] flag=true break
               后续判断 if(flag) {return false}
               index++
```



```
var longestCommonPrefix = function(strs) {
            if(strs.length <= 1) {
                return '';
            }
            let index = 0, str = strs[0];
            let flag = false;
            while(index < str.length) {
                for(let i = 1; i < strs.length; i++) {
                    if(str[index] !== strs[i][index]) {
                        flag = true; // 这里记得flag为true 一旦不相等 就要 break
                        break;
                    }
                    console.log(i,index);
                    console.log(str[index]);
                    console.log(strs[i][index]);
                }
                if(flag) {
                    break;
                }
                debugger
                index++
                console.log(index);
            }
            return str.slice(0, index);
        };
```







## 13. 只出现一次重复的数

算法解析：



## 只出现一次重复的数

- set结构
- 异或运算
- 双重遍历
- 数组indexOf方法
  - https://blog.csdn.net/qq_43412333/article/details/102594584?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164264305616780255262500%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164264305616780255262500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-102594584.pc_search_result_control_group&utm_term=%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97&spm=1018.2226.3001.4187



## set结构

思路：

补充知识点：

- set结构是什么



- set结构的一些方法



- set结构转化为数组



代码展示：





## 异或运算

思路：

补充知识点：

- 异或运算是什么





代码展示：





## 双重for循环

思路：





代码展示：



## 数组方法 indexOf 结合 splice

思路：

补充知识点：

- indexOf



- splice





代码展示：







# 5. 栈

## 栈的概念

- 注意：JavaScript没有栈的直接数据结构。

- 可以把栈类比为数组，数组可以实现增删改查，栈也可以；但是栈不能随便增删改查。栈必须是**先进后出**，只有一个入口进行操作。

- 添加数据叫做入栈；删除数据叫做出栈

- 类比：往一个杯子里面放饼干，放完之后，要修改倒数第二个饼干，必须把最后一个饼干先拿出来，再去修改倒数第二个饼干。

  - 修改一个栈的流程

  - ```
    [1,2,3]
    [1,2] 3
    [1,] 2,3
    [1,2],3
    [1,2,3]
    ```

    

- ```javascript
  class Stack {
  
      // 定义一个数组
      constructor() {
          this.stack = [];
      }
      // 1. 增加栈的数据
      push(item) {
          return this.stack.push(item);
      }
      // 2. 删除栈的数据
      pop(item) {
          return this.stack.push(item);
      }
      // 3. 读取栈的数据
      peek() {
          // 注意，读取栈的数据不能随便读取，只能读取最外层的。饼干堆到盒子里，每次只能看见最上面那层的饼干。
          // 所以是数组的长度-1 的那个数据
          return this.stack[getSize() - 1]
      }
      // 4. 获取栈的数据有几个
      getSize() {
          return this.stack.length;
      }
      // 5. 判断栈的长度是否为空
      isEmpty() {
          return this.stack.length === 0;
      }
  }
  ```

  - 复习定义类，复习constructor

## 栈的应用 

- 面试题

- <img src="D:/heima/front/7.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/datastr/0%20%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20211118211727373.png" alt="image-20211118211727373" style="zoom:50%;" />

- 分析题目和测试用例

  - ```js
    // 分析用例得出结论
           // 1. 括号固定三类
           // 2. 括号必须成对出现
           // 3. 左边的最后一个括号必须和右边的第一个括号闭合；右边的左边的第一个括号，必须和右边的最后一个括号闭合。==>正好对应栈的结构
    ```

  - ```js
    思路：
            // 1. 用栈模拟括号的顺序
            // 2. 利用一个对象，键是左括号，值是右括号，表示括号的对应关系
    
    ```

  - ```js
    // 算法的流程：
           // 1. 遍历 s 这个字符串里面的每一个字符    for ……of 结构
           // 2. 如果遍历到左括号，就入栈，
           // 3. 如果遍历到右括号，要进行判断
           // 3.1 和谁进行判断？从栈里面取出栈顶的元素，谁是栈顶，就是最后一个进去的元素？这个元素取出来，和右边碰到的第一个括号进行判断   arr.pop()即可取出来
           // 3.2 如果相等，栈里面的这个元素就出栈，接下来如果又碰到左括号，还是要继续入栈
           // 3.3 如果不相等，就return false
           // 4. 遍历完之后，要求栈里面的元素是空， 所以最后要判断 return stack.getSize() === 0
    ```

  - 函数部分

    - ```js
      // 1. 创建一个函数
             var isValid = function (s) {
                 // 2. 创建一个对象 这个对象的键是左边的括号，值是右边的括号。这样能够表现括号的左右的对应关系
                 const Map = {
                     '{': '}',
                     '(': ')',
                     '[': ']'
                 };
                 // 3. 创建一个栈的实例。而栈的类在最下面定义好了
                 const myStack = new Stack();
                 // 4. for(let item of s)这个for item of s 的结构没学过，推测是遍历这个括号
                 for (let item of s) {
                     // 5. 通过['键名']来访问对象值、
                     // 若Map对象有item值等价于Map有这个键，就把 item push到栈里面去，等价于左括号入栈
                     if (Map[item]) {
                         myStack.push(item); // 栈里面都是左括号
                     } else {
                         // 6. else 表示 item不是左括号，而是右括号
                         const last = myStack.pop();
                         // 取出myStack最后一个值， 去对象Map里面找这个值,是Map[last],是右括号,
                         // last是从栈里取出的左括号，栈顶，最后一个进去的 
                         // 而item是遍历的字符串的右括号
      ```


                          if (item !== Map[last]) return false;
                          // 如果有一个不相等，就return false
                          // 如果相等，此时栈里面这个元素也踢出来了，继续遍历及性能比较
                      }
                  }
                  return myStack.getSize() === 0;
              }
    
      ```
    - 定义栈的部分
    
      - ```js
         // 定义一个栈的类
                class Stack {
                    // 定义一个数组
                    constructor() {
                        this.stack = [];
                    }
                    // 1. 增加栈的数据
                    push(item) {
                        return this.stack.push(item);
                    }
                    // 2. 删除栈的数据 切记 取出数据，直接把最后一个数据踢出去，不用加参数
                    pop() {
                        return this.stack.pop();
                    }
                    // 3. 读取栈的数据
                    peek() {
                        return this.stack[getSize() - 1]
                    }
                    // 4. 获取栈的数据有几个
                    getSize() {
                        return this.stack.length;
                    }
                    // 5. 判断栈的长度是否为空
                    isEmpty() {
                        return this.stack.length === 0;
                    }
                }
      ```

  ```
  
  ```

- 测试部分

      - ```js
         	   console.log(isValid('[])')); // true
                console.log(isValid('[]}}')); // true
                console.log(isValid('[]{}[]')); // false

    ```
      
    ```







# 6. 队列

## 2.1 队列的概念和实现

```js
// 2.1 队列的特点
// 本质是一个数组
// 和栈的比较。
    // 有两个口
    // 顺序是先进先出 后进后出

// 2.2 如何修改队列中的一个数字
// [1,2,3] - 取出2 修改为0
// 1 [2, 3] - 先取出1
// 1 2 [3] - 再取出2
// 1 0 [3] - 2修改为0
// [3, 1] - 1 先入队
// [3, 1, 0] - 0再入队
// 顺序和原来不同 所以要调整
// 3 [1, 0] - 取出3
// [1, 0, 3] - 3再入队
// 发现队列要修改一个值特别麻烦

// 2.2 声明一个队列
class Queue {
    constructor() {
        // 初始化一个数组
        this.queue = []
    }
    // 入队
    enQueue(item) {
        return this.queue.push(item)
    }
    // 出队
    deQueue(item) {
        return this.queue.shift(item)
    }
    // 取-查 作为食堂大妈 你只能看到第一个
    getHeader() {
        return this.queue[0]
    }
    // 长度
    getSize() {
        return this.queue.length
    }
    // 是否为空
    isEmpty() {
        return this.queue.length === 0
    }
}
```



## 2.2 队列应用

```js
        // 分析用例
        // 1. 窗口的大小固定 => size是给定的
        // 2. 调用next添加数字 => 需要一个变量来存储值
        // 3. 如果数字超过窗口的大小，就要剔除第一个进入的数字，后进入的数字和前面的再进行求平均值 => 如果前面的数字剔除了 要剪掉的
        const MovingAverage = function(size) {
            this.Queue = new Queue()
            this.sum = 0
            this.windowSize = size
        }
        MovingAverage.prototype.next = function(val) {
            // 入队
            this.Queue.enQueue(val)
            // 如果入队后，导致窗口大小超出了，就要剔除前面先进入的
            if(this.Queue.getSize() > this.windowSize) {
                // sum要减去头部的值
                this.sum -= this.Queue.getHeader()
                // 队列要从出队
                this.Queue.deQueue()
            }
            // 求和
            this.sum += val
            // 返回平均值
            return this.sum / this.Queue.getSize()
        }
        class Queue {
            constructor() {
                // 初始化一个数组
                this.queue = []
            }
            // 入队
            enQueue(item) {
                return this.queue.push(item)
            }
            // 出队
            deQueue(item) {
                return this.queue.shift(item)
            }
            // 取-查 作为食堂大妈 你只能看到第一个
            getHeader() {
                return this.queue[0]
            }
            // 长度
            getSize() {
                return this.queue.length
            }
            // 是否为空
            isEmpty() {
                return this.queue.length === 0
            }
        }
        const move = new MovingAverage(3)
        console.log(move.next(1))
        console.log(move.next(12))
        console.log(move.next(12))
        console.log(move.next(3))
        console.log(move.next(3))


        // PS:
        // 如何给原型挂载方法？
        // 1. 挂载一个方法时，原本的方法变成了构造函数了，因此要new 一个实例 不能直接调用
        // function User(name) {
        //     this.name = name
        // }
 
        // User.prototype.show = function () {
        //     console.log(this.name)
        // };
        // let Joker = new User.prototype.constructor("Joker");
        // Joker.show(); 
        // 也可以直接 let Joker = new User('需要的name值')

        // 2. 挂载多个方法时
        // 下面用了constructor属性的原因是什么?
        // 因为此时原型赋值给了一个新的对象 想要改回来就要 用constructor 指向原本的构造函数
        // 新的对象 => 新的构造函数,删除constructor打印下
        function User(name) {
            this.name = name
        }
 
        User.prototype = {
            constructor: User,
            show() {
                console.log(this.name)
            },
            hide() {

            }
        };
        console.log(User.prototype.constructor);
        let Joker = new User.prototype.constructor("Joker");
        Joker.show();
        Joker.hide();
```







# 7. 链表

## 3.1 链表的概念

1. 链表类似一个铁环，一环扣一环。链表的每个节点，存的是当前的值，和下一个链表的地址。
2. 链表的内存空间是不连续的。而数组的内存空间必须是连续的。
3. 链表的增删改查
   - 增加。查找到上一个节点，新增节点的next指向下一个节点【这个下一个节点来源于 查到的上一个节点的next prev.next】，上一个节点的next指向新增的节点，
   - 删除。查找到上一个节点，上一个节点的next指向为 [要删除的节点的next指向], 要删除的节点的next指向为null
   - 查：需要顺藤摸瓜，一个接着一个的查。
   - 改:  先需要查找到，顺藤摸瓜的查找，找到了可以直接修改`和栈与队列不同，找到了无需重新放回去`



## 3.2 链表的实现

```js
// 1. 定义类
// 2. throw 错误

// 1. 定义一个节点
class Node {
    // 1.1 每一个链表的节点，存储当前值，和下一个的地址
    constructor(v, next) {
        this.value = v;
        this.next = next;
    }
}

// 1. 定义一个链表类 增删改查

class LinkList {
    constructor() {
        // 1.1 链表的长度 类比数组length
        this.size = 0;
        // 1.2 初始化一个节点 因为链表必须有一个头 头的值和下一个地址都是空
        this.initNode = new Node(null, null);
    }


    /**
     * @name: 查找上一个节点
     * @msg: 
     * @param {*} header 初始化头节点，并且会往下指，发生变化
     * @param {*} index 要查找的节点值的索引
     * @param {*} currentIndex 游标，会发生变化
     * @return {*}
     */

    _find(header, index, currentIndex) {
        // 查找上一个节点
        if (index === currentIndex) return header;
        return this._find(header.next, index, currentIndex + 1);
    }

    _checkIndex(index) {
        // 判断值的索引的合法性 如果索引不在范围 就抛出错误
        if (index < 0 || index > this.size) throw new Error("节点超出范围");
    }

    // 2. 插入节点
    /**
     * @name:  插入节点
     * @msg: 
     * @param {*} v 节点值
     * @param {*} index 插入节点的位置
     * @return {*}
     */
    insertNode(v, index) {
        // 检测节点是否存在
        this._checkIndex(index);
        // 查找上一个节点 参数： 初始化的头节点 当前节点的索引 游标
        let prev = this._find(this.initNode, index, 0);

        // 当我们要往链表的结尾插入节点时 prev.next为空
        // 其它情况 我们插入的节点的next 为 prev.next
        // 赋值 从右往左
        // 1. 右边新的节点的next指向 prev.next 上一个节点的next[此时prev.next没有改变]
        // 2. 设置prev.next的值 上一个节点的next指向新增的节点
        prev.next = new Node(v, prev.next);
        // 链表的数量+1
        this.size++;
        // 返回 我们要插入的节点
        return prev.next;
    }

    /**
     * @name: 删除节点
     * @msg: 
     * @param {*} index 插入节点的位置
     * @return {*}
     */
    removeNode(index) {
        this._checkIndex(index);
        // 查到当前的节点 先找到当前节点的上一个节点
        let prev = this._find(this.initNode, index, 0);
        // 当前节点 就是上一个节点的下一个指向
        let node = prev.next;
        // 上一个节点的next改到  当前节点的next
        prev.next = node.next;
        // 当前的节点改为null 让他消失
        node.next = null;
        // 数组的长度减1 因为删除了一个元素
        this.size--;
        return node;
    }

    /**
    * @name: 查 查找当前的节点
    * @msg: 
    * @param {*} index 插入节点的位置
    * @return {*}
    */
    // 查
    getNode(index) {
        // 判断数据 合法
        this._checkIndex(index);
        // 数据的长度判断 如果不合法 无须查
        if (this.isEmpty()) return;
        // 跟上面find类似 当前节点的 上一个节点的 next 
        // 查找当前的节点
        return (this._find(this.initNode, index, 0)).next;
    }


    // 判空
    isEmpty() {
        return this.size === 0;
    }

    // 长度
    getSize() {
        return this.size;
        // 为什么不能直接通过类的this.size访问到长度，而要声明这样一个方法，因为通过方法返回一个值，比起直接访问类的长度要更加严谨
    }
}

export default LinkList;
```



链表的应用


```js
        let reverseList = (head) => {
            let cur = head
            let prev = null
            while (cur) {
                // 1. 临时变量 存储当前节点的next
                let temp = cur.next
                // 2. 当前节点的next 改指向上一个节点
                cur.next = prev
                // 3. 上一个节点 等于当前节点[相等于指针1 + 1]
                prev = cur
                // 4. 当前节点等于改变后一个节点[相等于指针2 + 1]
                cur = temp
            }
            return prev
        }
```

>我的困惑是：
>
>1. 这里的head指向的是一个数组传进来 head不是指头结点嘛
>2. 里面遍历cur.next是啥意思? 就是next是内置的方法喽，自动遍历?











# 9.查找

## 二分查找

>猜一个数字，10以内，先猜5，不管是小了还是大了，都能够排除一半的内容

一个字典，有100个元素，需要排除7次

有240000个单词，需要排除18次

>1. 使用大O表示法表示运算时间时，log指的就是log2
>
>2. 二分查找，对于包含n个元素的列表，最多需要log2N,也就是logN,
>
>3. 但列表是**==有序==**的时候，二分查找才会有效果

而如果是简单查找法查找元素时，最糟糕的情况下需要查看每个元素，就是8次。



```js
// 1. 二分查找的代码
        /**
         * @name: 
         * @test: test font
         * @msg: 
         * @param {*} list 要被查找的数组
         * @param {*} item 要查找的元素
         * @return {*} 这个元素在第几个位置
         */
        const binary_search = (list, item) => {
            // low是查找的范围的起始值 
            // high是查找的范围的最大值
            // mid是中间的位置，猜测的中间位置
            // guess是查找的指定值 item是查找的目标值
            let low = 0;
            let high = list.length - 1;
            while (low <= high) {
                let mid = Math.floor((low + high) / 2)
                let guess = list[mid]
                if (guess === item) {
                    return mid
                } else if (guess > item) {
                    // 猜大了，边界值变化 high => 变小
                    high = mid - 1
                } else {
                    // 猜小了，边界值变化 low => 变大
                    low = mid + 1
                }
            }
            return null

        }
        console.log(binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 9));
```



