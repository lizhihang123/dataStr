<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        class LinkNode {
            // 卡壳1 这个地方写错了
            constructor(val, next) {
                this.val = val
                this.next = next
            }
        }
        // 2. 
        let MyLinkedList = function () {
            // 卡壳2：不知道这个节点里面写什么
            this._size = 0
            this._head = null
            this._tail = null
        }
        // 3.1 获取指定位置节点的值
        MyLinkedList.prototype.getNode = function(index) {
            // 范围
            // 卡壳3：index >= this._size等于不能少，return null 而不是-1
            if (index < 0 || index >= this._size) return null
            // 正式查找 + 虚拟头结点
            let cur = new LinkNode(0, this._head)
            while(index-- >= 0) {
                cur = cur.next
            }
            return cur
        }
        // 3.2 get方法
        MyLinkedList.prototype.get = function (index) {
            if (index < 0 || index >= this._size) return -1
            // 卡壳4：这个方法的下面部分都卡壳了
            // if (index === this._size - 1) {
            // }
            // 其实下面只有这句，不要自己吓自己啦
            console.log(this.getNode(index).val);
            return this.getNode(index).val
        }

        // 3.3 addAtHead
        MyLinkedList.prototype.addAtHead = function(val) {
            const node = new LinkNode(val, this._head)
            this._head = node
            // 落了一句代码
            this._size++
            if (!this._tail) {
                this._tail = node
            }
            // 卡壳5：上面四句自己写的，接下来怎么写呢?
        }

        // 3.4 addAtTail
        MyLinkedList.prototype.addAtTail = function (val) {
            // const node = new LinkNode(val, null)
            // this._tail.next = node
            // this._tail = node
            // // 卡壳6：下面接着处理头部节点为空的情况？

            // 错误错误 应该先判断是否有尾巴节点 再来进行尾巴节点的赋值
            const node = new LinkNode(val, null)
            // 再次忘记
            this._size++
            if (this._tail) {
                this._tail.next = node
                this._tail = node
                return 
                // 后续不进行下去
            }
            // 如果尾巴为null，证明头也为null
            this._head = node
            this._tail = node
        }

        // 3.5 addAtIndex(index,val)
        // 参数的顺序 切记搞反哈
        MyLinkedList.prototype.addAtIndex = function(index, val) {
            // 排除条件很多
            // 范围超出【大于链表长度 出错】
            if (index > this._size) {
                return
            }
            // 尾巴 等于长度【出错】【可以取到this._size的原因是正好是在尾巴部分呗，特殊情况】
            if (index === this._size) {
                this.addAtTail(val)
                return
            }
            // 头部前面
            if (index <= 0) {
                this.addAtHead(val)
                return
            }
            // 既不是超过index 也不是正好等于长度 也不是小于等于0 走下面
            // 获取上一个节点的值
            console.log(this.addAtHead);
            const node = this.getNode(index - 1)
            node.next = new LinkNode(val, node.next)
            this._size++
            // 卡壳7：写到这里 不知如何进行下去 其实写好啦 自信些
        }

        // 3.6 deleteAtIndex
        MyLinkedList.prototype.deleteAtIndex = function (index) {
            if (index < 0 || index >= this._size) {
                return
            }
            // 卡壳8：严重卡壳 - index === 0 这个情况完全忽视了
            if (index === 0) {
                this._head = this._head.next
                if (index === this.size - 1) {
                    // 原本只有一个元素 删掉 一个都没了 头和尾巴都是null
                    this._tail = this._head
                }
                // 长度都需要--的
                this._size--
                // 这句return不能少
                return
            }
            // 卡壳9：严重卡壳，不管是不是删最后一个节点 都是先 node.next = node.next.next
            // 如果是最后一个 再给this._tail赋值就好
            const node = this.getNode(index - 1) 
            node.next = node.next.next
            // 最后一个节点删除 倒数第二个节点next -> null
            if (index === this._size - 1) {
                this._tail = node
            }
            // 中间节点删除 next -> 原本的next的还要next
            this._size--
            return
        }

        obj = new MyLinkedList()
        obj.addAtHead(1)
        obj.addAtTail(2)
        obj.addAtIndex(2, 3)
        obj.addAtIndex(3, 4)
        console.log(obj);
        var reverse = function(head) {
            if(!head || !head.next) return head;
            // 从后往前翻
            const pre = reverse(head.next);
            // !打印出来的pre都是undefined
            // console.log('pre是', pre, 'head' , head);
            head.next = pre.next;
            // 这里反转 ！关键
            pre.next = head;
            // console.log('pre是', pre, 'head是', head);
            return head;
        }

        var reverseList = function(head) {
            let cur = head;
            while(cur && cur.next) {
                cur = cur.next;
            }
            reverse(head);
            // 除非链表一开始就是空的 就返回它自己

            // !最后走到这里
            console.log(cur);
            console.log(head);
            debugger
            return cur;
        };
        var head = obj.getNode(0)
        console.log(reverseList(head));
        console.log(obj);

        // 1. 测试遇见错误1：反转链表是要传递头结点进去 而不是整个外部节点
        // 2. 疑惑点: 为啥要while循环 为了让cur递归变化
        // 3. 疑惑点: 为啥head.next最后是val为4 -》因为递归是从最后进入栈的 先开始执行
        // 4. return cur; 这里的cur为什么也能够发生变化

        // 演示代码
        // 1. 入栈
        // 1 -> 2 -> 3 -> 4
        // const pre = reverse(1.next);
        // const pre = reverse(2.next);
        // const pre = reverse(3.next);
        // const pre = reverse(4.next);


        // 2.出栈执行
        // head = 4
        // const pre = reverse(4.next);
        // return 4 因为4.next是null
        // head.next = pre.next; 4.next = 4.next 4.next依旧是null
        // prev.next = head; 4.next = 4 这句对4不重要
        // return 4节点 next是null

        // head = 3
        // const pre = reverse(3.next); reverse(3.next) 返回的是4 next是null
        // head.next = pre.next; 3.next = 4.next 让3 和 4的next指针都是null
        // prev.next = head; 4.next = 3 !反转 关键
        // return 3 next是null

        
        // head = 2
        // const pre = reverse(2.next); reverse(3.next) 返回的是3 next是null
        // head.next = pre.next; 2.next = 3.next 让2 和 3的next指针都是null
        // prev.next = head; 3.next = 2 !反转 关键
        // return 2 next是null

        
        // head = 1
        // const pre = reverse(1.next); reverse(1.next) 返回的是2 next是null
        // head.next = pre.next; 1.next = 2.next 让1 和 2的next指针都是null
        // prev.next = head; 2.next = 1 !反转 关键
        // return 1 next是null 头结点是null
        

    </script>
</body>
</html>