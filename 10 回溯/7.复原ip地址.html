<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /**
        读题：
        1.给定一个字符串，返回所有的有效的ip地址(字符串)组成的数组
        - 必须是四个整数 不能有其他字符
        - 必须是 0-255之间的数字
        - 用.号进行分割
        - 如果有0开头，并且0后面还有数字，那就是错误的

        s = "25525511135"
        ["255.255.11.135","255.255.111.35"]
        s = "0000"
        ["0.0.0.0"]
        s = "101023"
        ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

        2.进一步，每次只能最多割成三个字符串，并且要小于255
        */
        // var restoreIpAddresses = function (s) {
        //     // 貌似一点点头绪都没有 咋整
        //     // '255255'只给一个最简单的 如何分割
        //     // 从一个字符串 -> 另一个字符串
        //     // 先转化为数组 -> 再根据索引来进行分割
        //     function tracking(startIndex, endIndex) {
        //         let str = s.slice(0, 3)
        //         let num = str - 0
        //         let temp = ''
        //         if (num <= 255) {
        //             temp += str
        //         }
        //         console.log(temp);
        //         tracking(startIndex, startIndex + 3)
        //     }
        // };
        const restoreIpAddresses = function (s) {
            debugger
            let result = []
            function backtracking(s, startIndex, pointNum) {
                debugger
                // 如果pointNum等于3，就要跳出当前的循环
                // 为什么是等于3就要退出呢？因为pointNum是点号的数量 有3个点，就要return
                // 为什么要判断第四段子字符串是否合法，前面的难道都不需要去判断了嘛？前面的都是合法的，才能走到这里的
                if (pointNum === 3) {
                    if (isValid(s, startIndex, s.length - 1)) {
                        result.push(s)
                    }
                    return
                }
                // 起始位置是什么？
                // i小于什么，也就是结束位置是什么？
                for (let i = startIndex; i < s.length; i++) {
                    if (isValid(s, startIndex, i)) {
                        // 这里的 插入的位置是i+1吗？
                        // pointNum++是什么呢？
                        s = insertStr(s, i + 1, '.')
                        pointNum++
                        backtracking(s, startIndex + 2, pointNum)
                        pointNum--
                        s = deleteStr(s, i + 1)
                    } else {
                        break
                    }
                }
            }
            backtracking(s, 0, 0)
            return result
        }

        function isValid(s, start, end) {
            debugger
            // 1.如果start大于end值, 超出了边界 
            if (start > end) {
                return false
            }
            // 2.前导数字是0，就要return
            // 第一个数是0 || 开头和结尾不一致 意思是 不是一个字符 如果是一个字符那么start和end是一样的
            if (s[start] === '0' && start !== end) {
                return false
            }
            // 3.如果说不是数字 || 数字越界了 都要 return false
            let num = 0
            // i是小于等于end 为什么
            for (let i = start; i <= end; i++) {
                if (s[i] > '9' || s[i] < '0') {
                    return false
                }
                // 转化为数字
                num = num * 10 + (s[i] - 0)
                if (num > 255) {
                    return false
                }
            }
            return true
        }
        // 往JS的字符串的指定位置 插入字符
        function insertStr(source, start, newStr) {
            debugger
            return source.slice(0, start) + newStr + source.slice(start)
        }
        // 往JS的字符串的指定位置 删除字符
        function deleteStr(source, targetIndex) {
            debugger
            return source.slice(0, targetIndex) + source.slice(targetIndex + 1)
        }
        console.log(restoreIpAddresses("25525511135"));
    </script>
</body>

</html>